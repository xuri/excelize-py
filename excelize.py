"""Copyright 2024 The excelize Authors. All rights reserved. Use of this source
code is governed by a BSD-style license that can be found in the LICENSE file.

Package excelize-py is a Python port of Go Excelize library, providing a set of
functions that allow you to write and read from XLAM / XLSM / XLSX / XLTM / XLTX
files. Supports reading and writing spreadsheet documents generated by Microsoft
Excelâ„¢ 2007 and later. Supports complex components by high compatibility, and
provided streaming API for generating or reading data from a worksheet with huge
amounts of data. This library needs Python version 3.9 or later.
"""

from dataclasses import fields
from datetime import datetime, date, time
from enum import Enum
from typing import Tuple, get_args, get_origin
import types_go
from types_py import *
from ctypes import (
    byref,
    c_bool,
    c_char_p,
    c_char,
    c_int,
    c_ubyte,
    cast,
    CDLL,
    create_string_buffer,
    POINTER,
    pointer,
    string_at,
)
import os
import platform


def load_lib():
    system = platform.system().lower()
    arch = platform.architecture()[0]
    machine = platform.machine().lower()
    ext_map = {"linux": ".so", "darwin": ".dylib", "windows": ".dll"}
    arch_map = {
        "linux": {
            "64bit": {
                "x86_64": "amd64",
                "amd64": "amd64",
                "aarch64": "arm64",
            },
        },
        "darwin": {
            "64bit": {
                "x86_64": "amd64",
                "amd64": "amd64",
                "arm64": "arm64",
            },
        },
        "windows": {
            "64bit": {
                "x86_64": "amd64",
                "amd64": "amd64",
                "arm64": "arm64",
            },
        },
    }
    if system in ext_map and arch in arch_map.get(system, {}):
        arch_name = arch_map[system][arch].get(machine)
        if arch_name:
            return f"libexcelize.{arch_name}.{system}{ext_map[system]}"

    print("This platform or architecture is not supported.")
    exit(1)


lib = CDLL(os.path.join(os.path.dirname(__file__), load_lib()))
ENCODE = "utf-8"
__version__ = "0.0.2"
uppercase_words = ["xml"]


def py_to_base_ctype(py_value, c_type):
    """
    Convert a Python value to a specified C type.

    Args:
        py_value: The Python value to be converted. If the value is a string, it will be encoded.
        c_type: The target C type to which the Python value should be converted.

    Returns:
        The converted value in the specified C type.
    """
    return (
        c_type(py_value.encode(ENCODE)) if str is type(py_value) else c_type(py_value)
    )


def is_py_primitive_type(t: type) -> bool:
    """
    Check if the given type is a Python primitive type.

    Args:
        t (type): The type to check.

    Returns:
        bool: True if the type is a Python primitive type or an Enum subclass, False otherwise.
    """
    return True if issubclass(t, Enum) else t in {int, float, bool, str, bytes, complex}


def snake_to_pascal(snake_str: str) -> str:
    """
    Convert a snake_case string to PascalCase.

    Args:
        snake_str (str): The snake_case string to convert.

    Returns:
        str: The converted PascalCase string.
    """
    return "".join(
        word.upper() if word.lower() in uppercase_words else word.capitalize()
        for word in snake_str.split("_")
    )


def c_value_to_py(ctypes_instance, py_instance):
    """
    Convert a ctypes instance to a Python instance by mapping fields from the
    to the corresponding fields in the Python instance.

    Args:
        ctypes_instance: The ctypes instance representing the Go data structure.
        py_instance: The Python instance to populate with data from the ctypes instance.

    Returns:
        The populated Python instance, or None if the ctypes instance is None.
    """
    if ctypes_instance is None:
        return None
    for py_field in fields(py_instance):
        py_field_name = py_field.name
        c_field_name = snake_to_pascal(py_field.name)
        # The Go base type
        py_field_args = get_args(py_field.type)

        if type(None) not in py_field_args:
            if is_py_primitive_type(py_field.type):
                c_val = getattr(ctypes_instance, c_field_name)
                if c_val:
                    setattr(
                        py_instance,
                        py_field_name,
                        (c_val.decode(ENCODE) if str is py_field.type else c_val),
                    )
                    continue
            else:
                # The Go struct, for example: excelize.Options, convert sub fields recursively
                setattr(
                    py_instance,
                    py_field_name,
                    c_value_to_py(
                        getattr(ctypes_instance, c_field_name), py_field.type()
                    ),
                )
        else:
            if get_origin(py_field_args[0]) is not list:
                # Pointer of the Go data type, for example: *excelize.Options or *string
                value = getattr(ctypes_instance, c_field_name)
                if value:
                    if any(is_py_primitive_type(arg) for arg in py_field_args):
                        # Pointer of the Go basic data type, for example: *string
                        value = getattr(ctypes_instance, c_field_name)
                        setattr(
                            py_instance,
                            py_field_name,
                            (
                                value.contents.value.decode(ENCODE)
                                if str in py_field_args
                                else value.contents.value
                            ),
                        )
                    else:
                        # Pointer of the Go struct, for example: *excelize.Options
                        setattr(
                            py_instance,
                            py_field_name,
                            c_value_to_py(
                                value.contents,
                                py_field_args[0](),
                            ),
                        )
            else:
                # The Go data type array, for example:
                # []*excelize.Options, []excelize.Options, []string, []*string
                if type(None) not in get_args(get_args(py_field_args[0])[0]):
                    # The Go data type array, for example: []excelize.Options or []string
                    py_list = []
                    l = getattr(ctypes_instance, c_field_name + "Len")
                    c_array = getattr(ctypes_instance, c_field_name)
                    if c_array:
                        if is_py_primitive_type(get_args(py_field_args[0])[0]):
                            # The Go basic data type array, for example: []string
                            for i in range(l):
                                py_list.append(
                                    string_at(c_array[i]).decode(ENCODE)
                                    if str is get_args(py_field_args[0])[0]
                                    else c_array[i]
                                )
                        else:
                            # The Go struct array, for example: []excelize.Options
                            for i in range(l):
                                py_list.append(
                                    c_value_to_py(
                                        c_array[i], get_args(py_field_args[0])[0]()
                                    ),
                                )
                        setattr(py_instance, py_field_name, py_list)
                else:
                    # Pointer array of the Go data type, for example: []*excelize.Options or []*string
                    py_list = []
                    l = getattr(ctypes_instance, c_field_name + "Len")
                    c_array = getattr(ctypes_instance, c_field_name)
                    if c_array:
                        if is_py_primitive_type(
                            get_args(get_args(py_field_args[0])[0])[0]
                        ):
                            # Pointer array of the Go basic data type, for example: []*string
                            for i in range(l):
                                py_list.append(
                                    string_at(c_array[i]).decode(ENCODE)
                                    if str is get_args(get_args(py_field_args[0])[0])[0]
                                    else c_array[i].contents.value
                                )
                        else:
                            #  Pointer array of the Go struct, for example: []*excelize.Options
                            for i in range(l):
                                py_list.append(
                                    c_value_to_py(
                                        c_array[i].contents,
                                        get_args(get_args(py_field_args[0])[0])[0](),
                                    ),
                                )
                        setattr(py_instance, py_field_name, py_list)
    return py_instance


def get_c_field_type(struct, field_name):
    """
    Retrieve the type of a specified field from a C structure.

    Args:
        struct (ctypes.Structure): The C structure containing the fields.
        field_name (str): The name of the field whose type is to be retrieved.

    Returns:
        type: The type of the specified field if found, otherwise None.
    """
    for field in struct._fields_:
        if field[0] == field_name:
            return field[1]


def py_value_to_c(py_instance, ctypes_instance):
    """
    Converts a Python instance to a corresponding C instance using ctypes.

    This function recursively converts fields of a Python instance to their
    corresponding C types and assigns them to the provided ctypes instance.
    It handles primitive types, structs, pointers, and arrays.

    Args:
        py_instance (object): The Python instance to be converted.
        ctypes_instance (ctypes.Structure): The ctypes instance to which the
            converted values will be assigned.

    Returns:
        ctypes.Structure: The ctypes instance with the converted values from
            the Python instance.
    """
    if py_instance is None:
        return None
    for py_field in fields(py_instance):
        py_field_name = py_field.name
        c_field_name = snake_to_pascal(py_field.name)
        # The Go base type
        py_field_args = get_args(py_field.type)

        if type(None) not in py_field_args:
            if is_py_primitive_type(py_field.type):
                if hasattr(py_instance, py_field_name):
                    c_type = get_c_field_type(ctypes_instance, c_field_name)
                    setattr(
                        ctypes_instance,
                        c_field_name,
                        py_to_base_ctype(getattr(py_instance, py_field_name), c_type),
                    )
                    continue
            else:
                # The Go struct, for example: excelize.Options, convert sub fields recursively
                c_type = get_c_field_type(ctypes_instance, c_field_name)
                if hasattr(py_instance, py_field_name):
                    setattr(
                        ctypes_instance,
                        c_field_name,
                        py_value_to_c(getattr(py_instance, py_field_name), c_type()),
                    )
        else:
            if get_origin(py_field_args[0]) is not list:
                # Pointer of the Go data type, for example: *excelize.Options or *string
                value = getattr(py_instance, py_field_name)
                c_type = get_c_field_type(ctypes_instance, c_field_name)._type_
                if value:
                    if any(is_py_primitive_type(arg) for arg in py_field_args):
                        # Pointer of the Go basic data type, for example: *string
                        setattr(
                            ctypes_instance,
                            c_field_name,
                            pointer(py_to_base_ctype(value, c_type)),
                        )
                    else:
                        # Pointer of the Go struct, for example: *excelize.Options
                        setattr(
                            ctypes_instance,
                            c_field_name,
                            pointer(py_value_to_c(value, c_type())),
                        )
            else:
                # The Go data type array, for example:
                # []*excelize.Options, []excelize.Options, []string, []*string
                py_field_type = get_args(py_field_args[0])[0]
                if type(None) not in get_args(py_field_type):
                    # The Go data type array, for example: []excelize.Options or []string
                    c_type = get_c_field_type(ctypes_instance, c_field_name)._type_
                    py_list = getattr(py_instance, py_field_name)
                    if py_list:
                        l = len(py_list)
                        c_array = (c_type * l)()
                        if is_py_primitive_type(py_field_type):
                            # The Go basic data type array, for example: []string
                            if str is py_field_type:
                                c_array_type = POINTER(c_char) * l
                                ctypes_instance.__setattr__(
                                    c_field_name,
                                    c_array_type(
                                        *[
                                            create_string_buffer(c.encode(ENCODE))
                                            for c in py_list
                                        ]
                                    ),
                                )
                            else:
                                for i in range(l):
                                    c_array.__setitem__(
                                        i, py_to_base_ctype(py_list[i], c_type)
                                    )
                                ctypes_instance.__setattr__(c_field_name, c_array)
                        else:
                            # The Go struct array, for example: []excelize.Options
                            for i in range(l):
                                c_array.__setitem__(
                                    i, py_value_to_c(py_list[i], c_type())
                                )
                            ctypes_instance.__setattr__(c_field_name, c_array)
                        ctypes_instance.__setattr__(c_field_name + "Len", c_int(l))

                else:
                    # Pointer array of the Go data type, for example: []*excelize.Options or []*string
                    c_type = get_c_field_type(
                        ctypes_instance, c_field_name
                    )._type_._type_
                    py_list = getattr(py_instance, py_field_name)
                    if py_list:
                        l = len(py_list)
                        c_array = (POINTER(c_type) * l)()
                        if is_py_primitive_type(get_args(py_field_type)[0]):
                            # Pointer array of the Go basic data type, for example: []*string
                            for i in range(l):
                                c_array.__setitem__(
                                    i,
                                    pointer(py_to_base_ctype(py_list[i], c_type)),
                                )
                        else:
                            #  Pointer array of the Go struct, for example: []*excelize.Options
                            for i in range(l):
                                c_array.__setitem__(
                                    i,
                                    pointer(py_value_to_c(py_list[i], c_type())),
                                )
                        ctypes_instance.__setattr__(c_field_name + "Len", c_int(l))
                        ctypes_instance.__setattr__(c_field_name, c_array)
    return ctypes_instance


def py_value_to_c_interface(py_value):
    """
    Converts a Python value to a C interface representation.

    Args:
        py_value: The Python value to be converted.

    Returns:
        An Interface object representing the Python value in a C-compatible format.

    Raises:
        TypeError: If the type of py_value is not supported.
    """
    type_mappings = {
        int: lambda: Interface(type=1, integer=py_value),
        str: lambda: Interface(type=2, string=py_value),
        float: lambda: Interface(type=3, float64=py_value),
        bool: lambda: Interface(type=4, boolean=py_value),
        datetime: lambda: Interface(type=5, integer=int(py_value.timestamp())),
        date: lambda: Interface(
            type=5, integer=int(datetime.combine(py_value, time.min).timestamp())
        ),
    }
    interface = type_mappings.get(type(py_value), lambda: Interface())()
    return py_value_to_c(interface, types_go._Interface())


class File:
    file_index: int

    def __init__(self, file_index):
        self.file_index = file_index

    def save(self, *opts: Options) -> Exception | None:
        """
        Override the spreadsheet with origin path.

        Args:
            *opts (Options): Optional parameters for saving the file.

        Returns:
            Exception | None: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        err, lib.Save.restype = None, c_char_p
        if len(opts) > 0:
            options = py_value_to_c(opts[0], types_go._Options())
            err = lib.Save(self.file_index, byref(options)).decode(ENCODE)
            return None if err == "" else err
        err = lib.Save(self.file_index, POINTER(types_go._Options)()).decode(ENCODE)
        return None if err == "" else Exception(err)

    def save_as(self, filename: str, *opts: Options) -> Exception | None:
        """
        Create or update to a spreadsheet at the provided path.

        Args:
            filename (str): The name of the file to save.
            *opts (Options): Optional parameters for saving the file.

        Returns:
            Exception | None: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        lib.SaveAs.restype = c_char_p
        options = (
            byref(py_value_to_c(opts[0], types_go._Options()))
            if opts
            else POINTER(types_go._Options)()
        )
        err = lib.SaveAs(self.file_index, filename.encode(ENCODE), options).decode(
            ENCODE
        )
        return None if err == "" else Exception(err)

    def add_chart(
        self, sheet: str, cell: str, chart: Chart, **combo: Chart
    ) -> Exception | None:
        """
        Add chart in a sheet by given chart format set (such as offset, scale,
        aspect ratio setting and print settings) and properties set.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference
            chart (Chart): Chart options
            **combo (Chart): Optional parameters for combo chart

        Returns:
            Exception | None: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        lib.AddChart.restype = c_char_p
        opts = [chart] + list(combo.values())
        charts = (types_go._Chart * len(opts))()
        for i, opt in enumerate(opts):
            charts[i] = py_value_to_c(opt, types_go._Chart())
        err = lib.AddChart(
            self.file_index,
            sheet.encode(ENCODE),
            cell.encode(ENCODE),
            byref(charts),
            len(charts),
        ).decode(ENCODE)
        return None if err == "" else Exception(err)

    def close(self) -> Exception | None:
        """
        Closes and cleanup the open temporary file for the spreadsheet.

        Returns:
            Exception | None: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        err, lib.Close.restype = None, c_char_p
        err = lib.Close(self.file_index).decode(ENCODE)
        return None if err == "" else Exception(err)

    def copy_sheet(self, src: int, to: int) -> Exception | None:
        """
        Duplicate a worksheet by gave source and target worksheet index. Note
        that currently doesn't support duplicate workbooks that contain tables,
        charts or pictures.

        Args:
            src (int): Source sheet index
            to (int): Target sheet index

        Returns:
            Exception | None: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        err, lib.CopySheet.restype = None, c_char_p
        err = lib.CopySheet(self.file_index, src, to).decode(ENCODE)
        return None if err == "" else Exception(err)

    def delete_chart(self, sheet: str, cell: str) -> Exception | None:
        """
        Delete chart in spreadsheet by given worksheet name and cell reference.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference

        Returns:
            Exception | None: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        err, lib.DeleteChart.restype = None, c_char_p
        err = lib.DeleteChart(
            self.file_index, sheet.encode(ENCODE), cell.encode(ENCODE)
        ).decode(ENCODE)
        return None if err == "" else Exception(err)

    def delete_comment(self, sheet: str, cell: str) -> Exception | None:
        """
        Delete comment in a worksheet by given worksheet name and cell reference.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference

        Returns:
            Exception | None: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        err, lib.DeleteComment.restype = None, c_char_p
        err = lib.DeleteComment(
            self.file_index, sheet.encode(ENCODE), cell.encode(ENCODE)
        ).decode(ENCODE)
        return None if err == "" else Exception(err)

    def delete_picture(self, sheet: str, cell: str) -> Exception | None:
        """
        Delete all pictures in a cell by given worksheet name and cell reference.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference

        Returns:
            Exception | None: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        err, lib.DeletePicture.restype = None, c_char_p
        err = lib.DeletePicture(
            self.file_index, sheet.encode(ENCODE), cell.encode(ENCODE)
        ).decode(ENCODE)
        return None if err == "" else Exception(err)

    def delete_sheet(self, sheet: str) -> Exception | None:
        """
        Delete worksheet in a workbook by given worksheet name. Use this method
        with caution, which will affect changes in references such as formulas,
        charts, and so on. If there is any referenced value of the deleted
        worksheet, it will cause a file error when you open it. This function
        will be invalid when only one worksheet is left.

        Args:
            sheet (str): The worksheet name

        Returns:
            Exception | None: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        err, lib.DeleteSheet.restype = None, c_char_p
        err = lib.DeleteSheet(self.file_index, sheet.encode(ENCODE)).decode(ENCODE)
        return None if err == "" else Exception(err)

    def delete_slicer(self, name: str) -> Exception | None:
        """
        Delete a slicer by a given slicer name.

        Args:
            name (str): The slicer name

        Returns:
            Exception | None: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        err, lib.DeleteSlicer.restype = None, c_char_p
        err = lib.DeleteSlicer(self.file_index, name.encode(ENCODE)).decode(ENCODE)
        return None if err == "" else Exception(err)

    def duplicate_row(self, sheet: str, row: int) -> Exception | None:
        """
        Inserts a copy of specified row (by its Excel row number) below. Use
        this method with caution, which will affect changes in references such
        as formulas, charts, and so on. If there is any referenced value of the
        worksheet, it will cause a file error when you open it. The excelize
        only partially updates these references currently.

        Args:
            sheet (str): The worksheet name
            row (int): The row number

        Returns:
            Exception | None: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        err, lib.DuplicateRow.restype = None, c_char_p
        err = lib.DuplicateRow(self.file_index, sheet.encode(ENCODE), row).decode(
            ENCODE
        )
        return None if err == "" else Exception(err)

    def duplicate_row_to(self, sheet: str, row: int, row2: int) -> Exception | None:
        """
        Inserts a copy of specified row by it Excel number to specified row
        position moving down exists rows after target position. Use this method
        with caution, which will affect changes in references such as formulas,
        charts, and so on. If there is any referenced value of the worksheet, it
        will cause a file error when you open it. The excelize only partially
        updates these references currently.

        Args:
            sheet (str): The worksheet name
            row (int): The row number
            row2 (int): The row number

        Returns:
            Exception | None: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        err, lib.DuplicateRowTo.restype = None, c_char_p
        err = lib.DuplicateRowTo(
            self.file_index, sheet.encode(ENCODE), row, row2
        ).decode(ENCODE)
        return None if err == "" else Exception(err)

    def get_cell_value(
        self, sheet: str, cell: str, *opts: Options
    ) -> Tuple[str, Exception | None]:
        """
        Get formatted value from cell by given worksheet name and cell reference
        in spreadsheet. The return value is converted to the 'string' data type.
        This function is concurrency safe. If the cell format can be applied to
        the value of a cell, the applied value will be returned, otherwise the
        original value will be returned. All cells' values will be the same in a
        merged range.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference
            *opts (Options): Optional parameters for get cell value

        Returns:
            Tuple[str, Exception | None]: A tuple containing the cell value as a
            string and an exception if an error occurred, otherwise None.
        """
        lib.GetCellValue.restype = types_go._GetCellValueResult
        options = (
            byref(py_value_to_c(opts[0], types_go._Options()))
            if opts
            else POINTER(types_go._Options)()
        )
        res = lib.GetCellValue(
            self.file_index, sheet.encode(ENCODE), cell.encode(ENCODE), options
        )
        err = res.err.decode(ENCODE)
        return res.val.decode(ENCODE), None if err == "" else Exception(err)

    def get_rows(
        self, sheet: str, *opts: Options
    ) -> Tuple[list[list[str]], Exception | None]:
        """
        Return all the rows in a sheet by given worksheet name, returned as a
        two-dimensional array, where the value of the cell is converted to the
        string type. If the cell format can be applied to the value of the cell,
        the applied value will be used, otherwise the original value will be
        used. GetRows fetched the rows with value or formula cells, the
        continually blank cells in the tail of each row will be skipped, so the
        length of each row may be inconsistent.

        Args:
            sheet (str): The worksheet name
            *opts (Options): Optional parameters for get rows

        Returns:
            Tuple[str, Exception | None]: A tuple containing the cell value as a
            string and an exception if an error occurred, otherwise None.
        """
        lib.GetRows.restype = types_go._GetRowsResult
        rows = []
        options = (
            byref(py_value_to_c(opts[0], types_go._Options()))
            if opts
            else POINTER(types_go._Options)()
        )
        res = lib.GetRows(self.file_index, sheet.encode(ENCODE), options)
        err = res.err.decode(ENCODE)
        result = c_value_to_py(res, GetRowsResult()).row

        if result:
            for row in result:
                if row.cell:
                    rows.append([cell for cell in row.cell])

        return rows, None if err == "" else Exception(err)

    def new_sheet(self, sheet: str) -> Tuple[int, Exception | None]:
        """
        Create a new sheet by given a worksheet name and returns the index of
        the sheets in the workbook after it appended. Note that when creating a
        new workbook, the default worksheet named `Sheet1` will be created.

        Args:
            sheet (str): The worksheet name

        Returns:
            Tuple[int, Exception | None]: A tuple containing the index of the
            new sheet and an Exception if an error occurred, otherwise None.
        """
        lib.NewSheet.restype = types_go._NewSheetResult
        res = lib.NewSheet(self.file_index, sheet.encode(ENCODE))
        err = res.err.decode(ENCODE)
        return res.idx, None if err == "" else Exception(err)

    def new_style(self, style: Style) -> Tuple[int, Exception | None]:
        """
        Create the style for cells by a given style options, and returns style
        index. The same style index can not be used across different workbook.
        This function is concurrency safe. Note that the 'Font.Color' field uses
        an RGB color represented in 'RRGGBB' hexadecimal notation.

        Args:
            style (Style): The style options

        Returns:
            Tuple[int, Exception | None]: A tuple containing the style index
            and an exception if any error occurs.
        """
        lib.NewStyle.restype = types_go._NewStyleResult
        options = py_value_to_c(style, types_go._Style())
        res = lib.NewStyle(self.file_index, byref(options))
        err = res.err.decode(ENCODE)
        return res.style, None if err == "" else Exception(err)

    def get_style(self, style_id: int) -> Tuple[Style | None, Exception | None]:
        """
        Get style definition by given style index.

        Args:
            style_id (int): The style ID

        Returns:
            Tuple[Style | None, Exception | None]: A tuple containing the Style
            object if found, otherwise None, and an Exception object if an error
            occurred, otherwise None.
        """
        lib.GetStyle.restype = types_go._GetStyleResult
        res = lib.GetStyle(self.file_index, c_int(style_id))
        err = res.err.decode(ENCODE)
        if err == "":
            return c_value_to_py(res.style, Style()), None
        return None, Exception(err)

    def set_active_sheet(self, index: int) -> Exception | None:
        """
        Set the default active sheet of the workbook by a given index. Note that
        the active index is different from the ID returned by function
        get_sheet_map. It should be greater than or equal to 0 and less than the
        total worksheet numbers.

        Parameters:
        index (int): The sheet index

        Returns:
            Exception | None: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        err, lib.SetActiveSheet.restype = None, c_char_p
        err = lib.SetActiveSheet(self.file_index, index).decode(ENCODE)
        return None if err == "" else Exception(err)

    def set_cell_style(
        self, sheet: str, top_left_cell: str, bottom_right_cell: str, style_id: int
    ) -> Exception | None:
        """
        Add style attribute for cells by given worksheet name, range reference
        and style ID. Note that diagonalDown and diagonalUp type border should
        be use same color in the same range. SetCellStyle will overwrite the
        existing styles for the cell, it won't append or merge style with
        existing styles.

        Args:
            sheet (str): The worksheet name
            top_left_cell (str): The top-left cell reference
            bottom_right_cell (str): The right-bottom cell reference
            style_id (int): The style ID

        Returns:
            Exception | None: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        lib.SetCellStyle.restype = c_char_p
        err = lib.SetCellStyle(
            self.file_index,
            sheet.encode(ENCODE),
            top_left_cell.encode(ENCODE),
            bottom_right_cell.encode(ENCODE),
            style_id,
        ).decode(ENCODE)
        return None if err == "" else Exception(err)

    def set_cell_value(
        self, sheet: str, cell: str, value: None | int | str | bool | datetime | date
    ) -> Exception | None:
        """
        Set the value of a cell. The specified coordinates should not be in the
        first row of the table, a complex number can be set with string text.

        Note that default date format is m/d/yy h:mm of time.Time type value.
        You can set numbers format by the SetCellStyle function. If you need to
        set the specialized date in Excel like January 0, 1900 or February 29,
        1900, these times can not representation in Go language time.Time data
        type. Please set the cell value as number 0 or 60, then create and bind
        the date-time number format style for the cell.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference
            value (None | int | str | bool | datetime | date): The cell value to be write

        Returns:
            Exception | None: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        lib.SetCellValue.restype = c_char_p
        err = lib.SetCellValue(
            self.file_index,
            sheet.encode(ENCODE),
            cell.encode(ENCODE),
            byref(py_value_to_c_interface(value)),
        ).decode(ENCODE)
        return None if err == "" else Exception(err)

    def set_sheet_background_from_bytes(
        self, sheet: str, extension: str, picture: bytes
    ) -> Exception | None:
        """
        Set background picture by given worksheet name, extension name and image
        data. Supported image types: BMP, EMF, EMZ, GIF, JPEG, JPG, PNG, SVG,
        TIF, TIFF, WMF, and WMZ.

        Args:
            sheet (str): The worksheet name
            extension (str): The image extension
            picture (bytes): The contents buffer of the file

        Returns:
            Exception | None: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        lib.SetSheetBackgroundFromBytes.restype = c_char_p
        err = lib.SetSheetBackgroundFromBytes(
            self.file_index,
            sheet.encode(ENCODE),
            extension.encode(ENCODE),
            cast(picture, POINTER(c_ubyte)),
            len(picture),
        ).decode(ENCODE)
        return None if err == "" else Exception(err)

    def set_sheet_row(
        self,
        sheet: str,
        cell: str,
        values: list[None | int | str | bool | datetime | date],
    ) -> Exception | None:
        """
        Writes cells to row by given worksheet name, starting cell reference and
        cell values list.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference
            values (bytes): The cell values

        Returns:
            Exception | None: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        lib.SetSheetRow.restype = c_char_p
        vals = (types_go._Interface * len(values))()
        for i, value in enumerate(values):
            vals[i] = py_value_to_c_interface(value)
        err = lib.SetSheetRow(
            self.file_index,
            sheet.encode(ENCODE),
            cell.encode(ENCODE),
            byref(vals),
            len(vals),
        ).decode(ENCODE)
        return None if err == "" else Exception(err)


def coordinates_to_cell_name(
    col: int, row: int, *abs: bool
) -> Tuple[str, Exception | None]:
    """
    Converts [X, Y] coordinates to alpha-numeric cell name or returns an error.

    Args:
        col (int): The column number.
        row (int): The row number.
        *abs (bool): Optional boolean indicating whether to use absolute
        references. If provided and True, the cell name will use absolute
        references (e.g., $A$1).

    Returns:
        Tuple[str, Exception | None]: A tuple containing the cell name as a
        string and an Exception if an error occurred, otherwise None.
    """
    lib.CoordinatesToCellName.restype = types_go._CoordinatesToCellNameResult
    options = False
    if len(abs) > 0:
        options = abs[0]
    res = lib.CoordinatesToCellName(col, row, c_bool(options))
    err = res.err.decode(ENCODE)
    return res.cell.decode(ENCODE), None if err == "" else Exception(err)


def new_file() -> File:
    """
    Create new file by default template.

    Returns:
        File: A populated spreadsheet file struct.
    """
    return File(lib.NewFile())


def open_file(filename: str, *opts: Options) -> Tuple[File | None, Exception | None]:
    """
    OpenFile take the name of a spreadsheet file and returns a populated
    spreadsheet file struct for it.

    Args:
        filename (str): The path to the Excel file to open.
        *opts (Options): Optional parameters for opening the file.

    Returns:
        Tuple[File | None, Exception | None]: A tuple containing a File object
        if successful, or None and an Exception if an error occurred.
    """
    lib.OpenFile.restype, options = types_go._OptionsResult, None
    if len(opts) > 0:
        options = byref(py_value_to_c(opts[0], types_go._Options()))
    res = lib.OpenFile(filename.encode(ENCODE), options)
    err = res.err.decode(ENCODE)
    if err == "":
        return File(res.idx), None
    return None, Exception(err)
