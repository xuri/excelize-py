"""Copyright 2024 - 2025 The excelize Authors. All rights reserved. Use of this
source code is governed by a BSD-style license that can be found in the LICENSE
file.

Package excelize-py is a Python port of Go Excelize library, providing a set of
functions that allow you to write and read from XLAM / XLSM / XLSX / XLTM / XLTX
files. Supports reading and writing spreadsheet documents generated by Microsoft
Excelâ„¢ 2007 and later. Supports complex components by high compatibility, and
provided streaming API for generating or reading data from a worksheet with huge
amounts of data. This library needs Python version 3.9 or later.
"""

from dataclasses import fields
from datetime import datetime, date, time
from enum import Enum
from typing import Tuple, get_args, get_origin, Dict, List, Optional, Union
from ctypes import (
    byref,
    c_bool,
    c_char_p,
    c_char,
    c_double,
    c_int,
    c_ubyte,
    cast,
    CDLL,
    create_string_buffer,
    POINTER,
    pointer,
    string_at,
)
import os
import platform
import sys
import types_go
from types_py import *


def load_lib() -> Optional[str]:
    """
    Load the shared library based on the current platform and architecture.
    """
    system = platform.system().lower()
    arch = platform.architecture()[0]
    machine = platform.machine().lower()
    ext_map = {"linux": ".so", "darwin": ".dylib", "windows": ".dll"}
    arch_map = {
        "linux": {
            "64bit": {
                "x86_64": "amd64",
                "amd64": "amd64",
                "aarch64": "arm64",
            },
            "32bit": {
                "x86": "386",
                "i386": "386",
                "i686": "386",
                "amd64": "386",
            },
        },
        "darwin": {
            "64bit": {
                "x86_64": "amd64",
                "amd64": "amd64",
                "arm64": "arm64",
            },
        },
        "windows": {
            "64bit": {
                "x86_64": "amd64",
                "amd64": "amd64",
                "arm64": "arm64",
            },
            "32bit": {
                "x86": "386",
                "i386": "386",
                "i686": "386",
                "amd64": "386",
            },
        },
    }
    if system in ext_map and arch in arch_map.get(system, {}):
        arch_name = arch_map[system][arch].get(machine)
        if arch_name:
            return f"libexcelize.{arch_name}.{system}{ext_map[system]}"

    print("This platform or architecture is not supported.")
    sys.exit(1)


lib = CDLL(os.path.join(os.path.dirname(__file__), load_lib()))
ENCODE = "utf-8"
__version__ = "0.0.4"
uppercase_words = ["id", "rgb", "sq", "xml"]


def py_to_base_ctype(py_value, c_type):
    """
    Convert a Python value to a specified C type.

    Args:
        py_value: The Python value to be converted. If the value is a string, it will be encoded.
        c_type: The target C type to which the Python value should be converted.

    Returns:
        The converted value in the specified C type.
    """
    return (
        c_type(py_value.encode(ENCODE)) if str is type(py_value) else c_type(py_value)
    )


def is_py_primitive_type(t: type) -> bool:
    """
    Check if the given type is a Python primitive type.

    Args:
        t (type): The type to check.

    Returns:
        bool: True if the type is a Python primitive type or an Enum subclass, False otherwise.
    """
    return True if issubclass(t, Enum) else t in {int, float, bool, str, bytes, complex}


def snake_to_pascal(snake_str: str) -> str:
    """
    Convert a snake_case string to PascalCase.

    Args:
        snake_str (str): The snake_case string to convert.

    Returns:
        str: The converted PascalCase string.
    """
    return "".join(
        word.upper() if word.lower() in uppercase_words else word.capitalize()
        for word in snake_str.split("_")
    )


def c_value_to_py(ctypes_instance, py_instance):
    """
    Convert a ctypes instance to a Python instance by mapping fields from the
    to the corresponding fields in the Python instance.

    Args:
        ctypes_instance: The ctypes instance representing the Go data structure.
        py_instance: The Python instance to populate with data from the ctypes instance.

    Returns:
        The populated Python instance, or None if the ctypes instance is None.
    """
    if ctypes_instance is None:
        return None
    for py_field in fields(py_instance):
        py_field_name = py_field.name
        c_field_name = snake_to_pascal(py_field.name)
        # The Go base type
        py_field_args = get_args(py_field.type)

        if type(None) not in py_field_args:
            if is_py_primitive_type(py_field.type):
                c_val = getattr(ctypes_instance, c_field_name)
                if c_val:
                    setattr(
                        py_instance,
                        py_field_name,
                        (c_val.decode(ENCODE) if str is py_field.type else c_val),
                    )
                    continue
            else:
                # The Go struct, for example: excelize.Options, convert sub fields recursively
                setattr(
                    py_instance,
                    py_field_name,
                    c_value_to_py(
                        getattr(ctypes_instance, c_field_name), py_field.type()
                    ),
                )
        else:
            if get_origin(py_field_args[0]) is not list:
                # Pointer of the Go data type, for example: *excelize.Options or *string
                value = getattr(ctypes_instance, c_field_name)
                if value:
                    if any(is_py_primitive_type(arg) for arg in py_field_args):
                        # Pointer of the Go basic data type, for example: *string
                        setattr(
                            py_instance,
                            py_field_name,
                            (
                                value.contents.value.decode(ENCODE)
                                if str in py_field_args
                                else value.contents.value
                            ),
                        )
                    else:
                        # Pointer of the Go struct, for example: *excelize.Options
                        setattr(
                            py_instance,
                            py_field_name,
                            c_value_to_py(
                                value.contents,
                                py_field_args[0](),
                            ),
                        )
            else:
                # The Go data type array, for example:
                # []*excelize.Options, []excelize.Options, []string, []*string
                if type(None) not in get_args(get_args(py_field_args[0])[0]):
                    # The Go data type array, for example: []excelize.Options or []string
                    py_list = []
                    l = getattr(ctypes_instance, c_field_name + "Len")
                    c_array = getattr(ctypes_instance, c_field_name)
                    if c_array:
                        if is_py_primitive_type(get_args(py_field_args[0])[0]):
                            # The Go basic data type array, for example: []string
                            for i in range(l):
                                py_list.append(
                                    string_at(c_array[i]).decode(ENCODE)
                                    if str is get_args(py_field_args[0])[0]
                                    else c_array[i]
                                )
                        else:
                            # The Go struct array, for example: []excelize.Options
                            for i in range(l):
                                py_list.append(
                                    c_value_to_py(
                                        c_array[i],
                                        get_args(py_field_args[0])[0](),
                                    ),
                                )
                        setattr(py_instance, py_field_name, py_list)
                else:
                    # Pointer array of the Go data type, for example:
                    # []*excelize.Options or []*string
                    py_list = []
                    l = getattr(ctypes_instance, c_field_name + "Len")
                    c_array = getattr(ctypes_instance, c_field_name)
                    if c_array:
                        if is_py_primitive_type(
                            get_args(get_args(py_field_args[0])[0])[0]
                        ):
                            # Pointer array of the Go basic data type, for example: []*string
                            for i in range(l):
                                py_list.append(
                                    string_at(c_array[i]).decode(ENCODE)
                                    if str is get_args(get_args(py_field_args[0])[0])[0]
                                    else c_array[i].contents.value
                                )
                        else:
                            #  Pointer array of the Go struct, for example: []*excelize.Options
                            for i in range(l):
                                py_list.append(
                                    c_value_to_py(
                                        c_array[i].contents,
                                        get_args(get_args(py_field_args[0])[0])[0](),
                                    ),
                                )
                        setattr(py_instance, py_field_name, py_list)
    return py_instance


def get_c_field_type(struct, field_name):
    """
    Retrieve the type of a specified field from a C structure.

    Args:
        struct (ctypes.Structure): The C structure containing the fields.
        field_name (str): The name of the field whose type is to be retrieved.

    Returns:
        type: The type of the specified field if found, otherwise None.
    """
    for field in getattr(struct, "_fields_", None):
        if field[0] == field_name:
            return field[1]


def py_value_to_c(py_instance, ctypes_instance):
    """
    Converts a Python instance to a corresponding C instance using ctypes.

    This function recursively converts fields of a Python instance to their
    corresponding C types and assigns them to the provided ctypes instance.
    It handles primitive types, structs, pointers, and arrays.

    Args:
        py_instance (object): The Python instance to be converted.
        ctypes_instance (ctypes.Structure): The ctypes instance to which the
            converted values will be assigned.

    Returns:
        ctypes.Structure: The ctypes instance with the converted values from
            the Python instance.
    """
    if py_instance is None:
        return None
    for py_field in fields(py_instance):
        py_field_name = py_field.name
        c_field_name = snake_to_pascal(py_field.name)
        # The Go base type
        py_field_args = get_args(py_field.type)

        if type(None) not in py_field_args:
            if is_py_primitive_type(py_field.type):
                if hasattr(py_instance, py_field_name):
                    c_type = get_c_field_type(ctypes_instance, c_field_name)
                    setattr(
                        ctypes_instance,
                        c_field_name,
                        py_to_base_ctype(getattr(py_instance, py_field_name), c_type),
                    )
                    continue
            else:
                # The Go struct, for example: excelize.Options, convert sub fields recursively
                c_type = get_c_field_type(ctypes_instance, c_field_name)
                if hasattr(py_instance, py_field_name):
                    setattr(
                        ctypes_instance,
                        c_field_name,
                        py_value_to_c(getattr(py_instance, py_field_name), c_type()),
                    )
        else:
            arg_type = py_field_args[0]
            if get_origin(arg_type) is not list and arg_type is not bytes:
                # Pointer of the Go data type, for example: *excelize.Options or *string
                value = getattr(py_instance, py_field_name)
                c_type = getattr(
                    get_c_field_type(ctypes_instance, c_field_name), "_type_", None
                )
                if value is not None:
                    if any(is_py_primitive_type(arg) for arg in py_field_args):
                        # Pointer of the Go basic data type, for example: *string
                        setattr(
                            ctypes_instance,
                            c_field_name,
                            pointer(py_to_base_ctype(value, c_type)),
                        )
                    else:
                        # Pointer of the Go struct, for example: *excelize.Options
                        setattr(
                            ctypes_instance,
                            c_field_name,
                            pointer(py_value_to_c(value, c_type())),
                        )
            else:
                # The Go data type array, for example:
                # []*excelize.Options, []excelize.Options, []string, []*string
                if arg_type is bytes:  # []byte
                    c_type = getattr(
                        get_c_field_type(ctypes_instance, c_field_name), "_type_", None
                    )
                    value = getattr(py_instance, py_field_name)
                    if value is not None:
                        setattr(
                            ctypes_instance, c_field_name, cast(value, POINTER(c_ubyte))
                        )
                        setattr(
                            ctypes_instance, c_field_name + "Len", c_int(len(value))
                        )
                    continue
                py_field_type = get_args(arg_type)[0]
                if type(None) not in get_args(py_field_type):
                    # The Go data type array, for example: []excelize.Options or []string
                    c_type = getattr(
                        get_c_field_type(ctypes_instance, c_field_name), "_type_", None
                    )
                    py_list = getattr(py_instance, py_field_name)
                    if py_list:
                        l = len(py_list)
                        c_array = (c_type * l)()
                        if is_py_primitive_type(py_field_type):
                            # The Go basic data type array, for example: []string
                            if str is py_field_type:
                                c_array_type = POINTER(c_char) * l
                                setattr(
                                    ctypes_instance,
                                    c_field_name,
                                    c_array_type(
                                        *[
                                            create_string_buffer(c.encode(ENCODE))
                                            for c in py_list
                                        ]
                                    ),
                                )
                            else:
                                for i in range(l):
                                    c_array[i] = py_to_base_ctype(py_list[i], c_type)
                                setattr(ctypes_instance, c_field_name, c_array)
                        else:
                            # The Go struct array, for example: []excelize.Options
                            for i in range(l):
                                c_array[i] = py_value_to_c(py_list[i], c_type())
                            setattr(ctypes_instance, c_field_name, c_array)
                        setattr(ctypes_instance, c_field_name + "Len", c_int(l))

                else:
                    # Pointer array of the Go data type, for example:
                    # []*excelize.Options or []*string
                    c_type = getattr(
                        getattr(
                            get_c_field_type(ctypes_instance, c_field_name),
                            "_type_",
                            None,
                        ),
                        "_type_",
                        None,
                    )
                    py_list = getattr(py_instance, py_field_name)
                    if py_list:
                        l = len(py_list)
                        c_array = (POINTER(c_type) * l)()
                        if is_py_primitive_type(get_args(py_field_type)[0]):
                            # Pointer array of the Go basic data type, for example: []*string
                            for i in range(l):
                                c_array[i] = pointer(
                                    py_to_base_ctype(py_list[i], c_type)
                                )
                        else:
                            #  Pointer array of the Go struct, for example: []*excelize.Options
                            for i in range(l):
                                c_array[i] = pointer(
                                    py_value_to_c(py_list[i], c_type())
                                )
                        setattr(ctypes_instance, c_field_name + "Len", c_int(l))
                        setattr(ctypes_instance, c_field_name, c_array)
    return ctypes_instance


def py_value_to_c_interface(py_value):
    """
    Converts a Python value to a C interface representation.

    Args:
        py_value: The Python value to be converted.

    Returns:
        An Interface object representing the Python value in a C-compatible format.

    Raises:
        TypeError: If the type of py_value is not supported.
    """
    type_mappings = {
        int: lambda: Interface(type=1, integer=py_value),
        str: lambda: Interface(type=2, string=py_value),
        float: lambda: Interface(type=3, float64=py_value),
        bool: lambda: Interface(type=4, boolean=py_value),
        datetime: lambda: Interface(type=5, integer=int(py_value.timestamp())),
        date: lambda: Interface(
            type=5,
            integer=int(datetime.combine(py_value, time.min).timestamp()),
        ),
    }
    interface = type_mappings.get(type(py_value), Interface)()
    return py_value_to_c(interface, types_go._Interface())


def prepare_args(args: List, types: List[argsRule]):
    """
    Validate arguments against expected types.

    Args:
        args (List): The arguments to validate.
        types (List[argsRule]): The expected argument rules.

    Raises:
        TypeError: If an argument type doesn't match the expected types.
    """
    if not types:
        return
    opts = types[-1].opts if types else False
    for i, excepted in enumerate(types):
        if opts and i >= len(args):
            return
        if i >= len(args):
            continue
        received = type(args[i])
        if received not in excepted.types:
            names = [t.__name__ for t in excepted.types]
            if len(names) == 1:
                t = names[0]
            else:
                t = ", ".join(names[:-1]) + f", or {names[-1]}"
            raise TypeError(
                f"expected type {t} for argument "
                f"'{excepted.name}', but got {received.__name__}"
            )


class StreamWriter:
    """
    StreamWriter is a streaming writer for writing large amounts of data to a
    worksheet.
    """

    sw_index: int

    def __init__(self, sw_index: int):
        self.sw_index = sw_index

    def add_table(self, table: Table) -> None:
        """
        Creates an Excel table for the stream writer using the given cell range
        and format set.

        Note that the table must be at least two lines including the header. The
        header cells must contain strings and must be unique. Currently, only
        one table is allowed for a stream writer. The function must be called
        after the rows are written but before `flush`.

        Args:
            table (Table): The table options

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            For example, create a table of A1:D5 on Sheet1:

            ```python
            try:
                sw.add_table(excelize.Table(range="A1:D5"))
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        prepare_args([table], [argsRule("table", [Table])])
        lib.StreamAddTable.restype = c_char_p
        options = py_value_to_c(table, types_go._Table())
        err = lib.StreamAddTable(self.sw_index, byref(options)).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def insert_page_break(self, cell: str) -> None:
        """
        Creates a page break to determine where the printed page ends and where
        begins the next one by a given cell reference, the content before the
        page break will be printed on one page and after the page break on
        another.

        Args:
            cell (str): The cell reference

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        prepare_args([cell], [argsRule("cell", [str])])
        lib.StreamInsertPageBreak.restype = c_char_p
        err = lib.StreamInsertPageBreak(self.sw_index, cell.encode(ENCODE)).decode(
            ENCODE
        )
        if err != "":
            raise RuntimeError(err)

    def merge_cell(self, top_left_cell: str, bottom_right_cell: str) -> None:
        """
        Merge cells by a given range reference for the stream writer. Don't
        create a merged cell that overlaps with another existing merged cell.

        Args:
            top_left_cell (str): The top-left cell reference
            bottom_right_cell (str): The right-bottom cell reference

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        prepare_args(
            [top_left_cell, bottom_right_cell],
            [
                argsRule("top_left_cell", [str]),
                argsRule("bottom_right_cell", [str]),
            ],
        )
        lib.StreamMergeCell.restype = c_char_p
        err = lib.StreamMergeCell(
            self.sw_index,
            top_left_cell.encode(ENCODE),
            bottom_right_cell.encode(ENCODE),
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def set_col_width(self, start_col: int, end_col: int, width: float) -> None:
        """
        Set the width of a single column or multiple columns for the stream
        writer. Note that you must call the `set_col_width` function before the
        `set_row` function.

        Args:
            start_col (int): The start column number
            end_col (int): The end column number
            width (float): The column width

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            For example set the width column B:C as 20:

            ```python
            try:
                sw.set_col_width(2, 3, 20)
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        prepare_args(
            [start_col, end_col, width],
            [
                argsRule("start_col", [int]),
                argsRule("end_col", [int]),
                argsRule("width", [float]),
            ],
        )
        lib.StreamSetColWidth.restype = c_char_p
        err = lib.StreamSetColWidth(
            self.sw_index, c_int(start_col), c_int(end_col), c_double(width)
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def set_panes(self, opts: Panes) -> None:
        """
        Create and remove freeze panes and split panes by giving panes options
        for the stream writer. Note that you must call the `set_panes` function
        before the `set_row` function.

        Args:
            opts (Panes): The panes options

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        prepare_args([opts], [argsRule("opts", [Panes])])
        lib.StreamSetPanes.restype = c_char_p
        options = py_value_to_c(opts, types_go._Panes())
        err = lib.StreamSetPanes(self.sw_index, byref(options)).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def set_row(
        self,
        cell: str,
        values: List[Union[None, int, str, bool, datetime, date]],
    ) -> None:
        """
        Writes an array to stream rows by giving starting cell reference and a
        pointer to an array of values. Note that you must call the `flush`
        function to end the streaming writing process.

        Args:
            cell (str): The cell reference
            values (List[Union[None, int, str, bool, datetime, date]]): The cell
            values

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        prepare_args(
            [cell, values],
            [argsRule("cell", [str]), argsRule("values", [list])],
        )
        lib.StreamSetRow.restype = c_char_p
        vals = (types_go._Interface * len(values))()
        for i, value in enumerate(values):
            vals[i] = py_value_to_c_interface(value)
        err = lib.StreamSetRow(
            self.sw_index,
            cell.encode(ENCODE),
            byref(vals),
            len(vals),
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def flush(self) -> None:
        """
        Ending the streaming writing process.

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        lib.StreamFlush.restype = c_char_p
        err = lib.StreamFlush(self.sw_index).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)


class File:
    """
    File is a representation of an workbook.
    """

    file_index: int

    def __init__(self, file_index: int):
        self.file_index = file_index

    def save(self, *opts: Options) -> None:
        """
        Override the spreadsheet with origin path.

        Args:
            *opts (Options): Optional parameters for saving the file.

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        prepare_args(
            [opts[0]] if opts else [],
            [argsRule("opts", [Options], True)],
        )
        err, lib.Save.restype = None, c_char_p
        options = POINTER(types_go._Options)()
        options = (
            byref(py_value_to_c(opts[0], types_go._Options()))
            if opts
            else POINTER(types_go._Options)()
        )
        err = lib.Save(self.file_index, options).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def save_as(self, filename: str, *opts: Options) -> None:
        """
        Create or update to a spreadsheet at the provided path.

        Args:
            filename (str): The name of the file to save.
            *opts (Options): Optional parameters for saving the file.

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        prepare_args(
            [filename, opts[0]] if opts else [filename],
            [argsRule("filename", [str]), argsRule("opts", [Options], True)],
        )
        lib.SaveAs.restype = c_char_p
        options = (
            byref(py_value_to_c(opts[0], types_go._Options()))
            if opts
            else POINTER(types_go._Options)()
        )
        err = lib.SaveAs(self.file_index, filename.encode(ENCODE), options).decode(
            ENCODE
        )
        if err != "":
            raise RuntimeError(err)

    def add_chart(self, sheet: str, cell: str, chart: Chart, **combo: Chart) -> None:
        """
        Add chart in a sheet by given chart format set (such as offset, scale,
        aspect ratio setting and print settings) and properties set.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference
            chart (Chart): Chart options
            **combo (Chart): Optional parameters for combo chart

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        The following shows the type of chart supported by excelize:

        | ID  | Enumeration                 | Chart                                    |
        |-----|-----------------------------|------------------------------------------|
        | 0   | Area                        | 2D area chart                            |
        | 1   | AreaStacked                 | 2D stacked area chart                    |
        | 2   | AreaPercentStacked          | 2D 100% stacked area chart               |
        | 3   | Area3D                      | 3D area chart                            |
        | 4   | Area3DStacked               | 3D stacked area chart                    |
        | 5   | Area3DPercentStacked        | 3D 100% stacked area chart               |
        | 6   | Bar                         | 2D clustered bar chart                   |
        | 7   | BarStacked                  | 2D stacked bar chart                     |
        | 8   | BarPercentStacked           | 2D 100% stacked bar chart                |
        | 9   | Bar3DClustered              | 3D clustered bar chart                   |
        | 10  | Bar3DStacked                | 3D stacked bar chart                     |
        | 11  | Bar3DPercentStacked         | 3D 100% stacked bar chart                |
        | 12  | Bar3DConeClustered          | 3D cone clustered bar chart              |
        | 13  | Bar3DConeStacked            | 3D cone stacked bar chart                |
        | 14  | Bar3DConePercentStacked     | 3D cone percent bar chart                |
        | 15  | Bar3DPyramidClustered       | 3D pyramid clustered bar chart           |
        | 16  | Bar3DPyramidStacked         | 3D pyramid stacked bar chart             |
        | 17  | Bar3DPyramidPercentStacked  | 3D pyramid percent stacked bar chart     |
        | 18  | Bar3DCylinderClustered      | 3D cylinder clustered bar chart          |
        | 19  | Bar3DCylinderStacked        | 3D cylinder stacked bar chart            |
        | 20  | Bar3DCylinderPercentStacked | 3D cylinder percent stacked bar chart    |
        | 21  | Col                         | 2D clustered column chart                |
        | 22  | ColStacked                  | 2D stacked column chart                  |
        | 23  | ColPercentStacked           | 2D 100% stacked column chart             |
        | 24  | Col3DClustered              | 3D clustered column chart                |
        | 25  | Col3D                       | 3D column chart                          |
        | 26  | Col3DStacked                | 3D stacked column chart                  |
        | 27  | Col3DPercentStacked         | 3D 100% stacked column chart             |
        | 28  | Col3DCone                   | 3D cone column chart                     |
        | 29  | Col3DConeClustered          | 3D cone clustered column chart           |
        | 30  | Col3DConeStacked            | 3D cone stacked column chart             |
        | 31  | Col3DConePercentStacked     | 3D cone percent stacked column chart     |
        | 32  | Col3DPyramid                | 3D pyramid column chart                  |
        | 33  | Col3DPyramidClustered       | 3D pyramid clustered column chart        |
        | 34  | Col3DPyramidStacked         | 3D pyramid stacked column chart          |
        | 35  | Col3DPyramidPercentStacked  | 3D pyramid percent stacked column chart  |
        | 36  | Col3DCylinder               | 3D cylinder column chart                 |
        | 37  | Col3DCylinderClustered      | 3D cylinder clustered column chart       |
        | 38  | Col3DCylinderStacked        | 3D cylinder stacked column chart         |
        | 39  | Col3DCylinderPercentStacked | 3D cylinder percent stacked column chart |
        | 40  | Doughnut                    | Doughnut chart                           |
        | 41  | Line                        | Line chart                               |
        | 42  | Line3D                      | 3D line chart                            |
        | 43  | Pie                         | Pie chart                                |
        | 44  | Pie3D                       | 3D pie chart                             |
        | 45  | PieOfPie                    | Pie of pie chart                         |
        | 46  | BarOfPie                    | Bar of pie chart                         |
        | 47  | Radar                       | Radar chart                              |
        | 48  | Scatter                     | Scatter chart                            |
        | 49  | Surface3D                   | 3D surface chart                         |
        | 50  | WireframeSurface3D          | 3D wireframe surface chart               |
        | 51  | Contour                     | Contour chart                            |
        | 52  | WireframeContour            | Wireframe contour chart                  |
        | 53  | Bubble                      | Bubble chart                             |
        | 54  | Bubble3D                    | 3D bubble chart                          |

        In Excel a chart series is a collection of information that defines
        which data is plotted such as values, axis labels and formatting.
        The series options that can be set are:

            name
            categories
            values
            fill
            legend
            line
            marker
            data_label
            data_label_position

        name: Set the name for the series. The name is displayed in the chart
        legend and in the formula bar. The 'name' property is optional and if it
        isn't supplied it will default to Series 1..n. The name can also be a
        formula such as Sheet1!$A$1

        categories: This sets the chart category labels. The category is more or
        less the same as the X axis. In most chart types the 'categories'
        property is optional and the chart will just assume a sequential series
        from 1..n.

        values: This is the most important property of a series and is the only
        mandatory option for every chart object. This option links the chart
        with the worksheet data that it displays.

        sizes: This sets the bubble size in a data series. The 'sizes' property
        is optional and the default value was same with 'values'.

        fill: This set the format for the data series fill. The 'fill' property
        is optional

        legend: This set the font of legend text for a data series. The 'legend'
        property is optional.

        line: This sets the line format of the line chart. The 'line' property
        is optional and if it isn't supplied it will default style. The options
        that can be set are width and color. The range of width is 0.25pt -
        999pt. If the value of width is outside the range, the default width of
        the line is 2pt.

        marker: This sets the marker of the line chart and scatter chart. The
        range of optional field 'size' is 2-72 (default value is 5). The
        enumeration value of optional field 'symbol' are (default value is
        'auto'):

            circle
            dash
            diamond
            dot
            none
            picture
            plus
            square
            star
            triangle
            x
            auto

        data_label: This sets the format of the chart series data label.

        data_label_position: This sets the position of the chart series data
        label.

        Set properties of the chart legend. The options that can be set are:

            position
            show_legend_key
            font

        position: Set the position of the chart legend. The default legend
        position is bottom. The available positions are:

            none
            top
            bottom
            left
            right
            top_right

        show_legend_key: Set the legend keys shall be shown in data labels.
        The default value is False.

        font: Set the font properties of the chart legend text. The properties
        that can be set are the same as the font object that is used for cell
        formatting. The font family, size, color, bold, italic, underline, and
        strike properties can be set.

        Set properties of the chart title. The properties that can be set are:

            title

        title: Set the name (title) for the chart. The name is displayed above
        the chart. The name can also be a formula such as Sheet1!$A$1 or a list
        with a sheet name. The name property is optional. The default is to have
        no chart title.

        Specifies how blank cells are plotted on the chart by 'show_blanks_as'.
        The default value is gap. The options that can be set are:

            gap
            span
            zero

        gap: Specifies that blank values shall be left as a gap.

        span: Specifies that blank values shall be spanned with a line.

        zero: Specifies that blank values shall be treated as zero.

        Specifies that each data marker in the series has a different color by
        'vary_colors'. The default value is True.

        Set chart offset, scale, aspect ratio setting and print settings by
        'format', same as function `add_picture`.

        Set the position of the chart plot area by 'plot_area'. The properties
        that can be set are:

            second_plot_values
            show_bubble_size
            show_cat_name
            show_data_table
            show_data_table_keys
            show_leader_lines
            show_percent
            show_ser_name
            show_val
            num_fmt

        second_plot_values: Specifies the values in second plot for the
        'PieOfPie' and 'BarOfPie' chart.

        show_bubble_size: Specifies the bubble size shall be shown in a data
        label. The 'show_bubble_size' property is optional. The default value is
        False.

        show_cat_name: Specifies that the category name shall be shown in the
        data label. The 'show_cat_name' property is optional. The default value
        is True.

        show_data_table: Used for add data table under chart, depending on the
        chart type, only available for area, bar, column and line series type
        charts. The 'show_data_table' property is optional. The default value is
        False.

        show_data_table_keys: Used for add legend key in data table, only works
        on 'show_data_table' is enabled. The 'show_data_table_keys' property is
        optional. The default value is False.

        show_leader_lines: Specifies leader lines shall be shown for data
        labels. The 'show_leader_lines' property is optional. The default value
        is False.

        show_percent: Specifies that the percentage shall be shown in a data
        label. The 'show_percent' property is optional. The default value is
        False.

        show_ser_name: Specifies that the series name shall be shown in a data
        label. The 'show_ser_name' property is optional. The default value is
        False.

        show_val: Specifies that the value shall be shown in a data label. The
        'show_val' property is optional. The default value is False.

        num_fmt: Specifies that if linked to source and set custom number format
        code for data labels. The 'NumFmt' property is optional. The default
        format code is 'General'.

        Set the primary horizontal and vertical axis options by 'x_axis' and
        'y_axis'. The properties of 'x_axis' that can be set are:

            none
            major_grid_lines
            minor_grid_lines
            tick_label_skip
            reverse_order
            maximum
            minimum
            alignment
            font
            num_fmt
            title

        The properties of 'y_axis' that can be set are:

            none
            major_grid_lines
            minor_grid_lines
            major_unit
            secondary
            reverse_order
            maximum
            minimum
            alignment
            font
            log_base
            num_fmt
            title

        none: Disable axes.

        major_grid_lines: Specifies major grid lines.

        minor_grid_lines: Specifies minor grid lines.

        major_unit: Specifies the distance between major ticks. Shall contain a
        positive floating-point number. The 'major_unit' property is optional.
        The default value is auto.

        secondary: Specifies the current series vertical axis as the secondary
        axis, this only works for the second and later chart in the combo chart.
        The default value is False.

        tick_label_skip: Specifies how many tick labels to skip between label
        that is drawn. The 'tick_label_skip' property is optional. The default
        value is auto.

        reverse_order: Specifies that the categories or values on reverse order
        (orientation of the chart). The 'reverse_order' property is optional. The
        default value is False.

        maximum: Specifies that the fixed maximum, 0 is auto. The 'maximum'
        property is optional. The default value is auto.

        minimum: Specifies that the fixed minimum, 0 is auto. The 'minimum'
        property is optional. The default value is auto.

        alignment: Specifies that the alignment of the horizontal and vertical
        axis. The properties of alignment that can be set are:

            text_rotation
            vertical

        The value of 'text_rotation' that can be set from -90 to 90.

        The value of 'vertical' that can be set are:

            horz
            vert
            vert270
            wordArtVert
            eaVert
            mongolianVert
            wordArtVertRtl

        font: Specifies that the font of the horizontal and vertical axis. The
        properties of font that can be set are:

            bold
            italic
            underline
            family
            size
            strike
            color
            vert_align

        log_base: Specifies logarithmic scale base number of the vertical axis.

        num_fmt: Specifies that if linked to source and set custom number format
        code for axis. The 'num_fmt' property is optional. The default format
        code is 'General'.

        title: Specifies that the primary horizontal or vertical axis title and
        resize chart. The 'title' property is optional.

        Set chart size by 'dimension' property. The 'dimension' property is
        optional. The default width is 480, and height is 260.

        Set chart legend for all data series by 'legend' property. The 'legend'
        property is optional.

        Set the bubble size in all data series for the bubble chart or 3D bubble
        chart by 'bubble_sizes' property. The 'bubble_sizes' property is
        optional. The default width is 100, and the value should be great than 0
        and less or equal than 300.

        Set the doughnut hole size in all data series for the doughnut chart by
        'hole_size' property. The 'hole_size' property is optional. The default
        width is 75, and the value should be great than 0 and less or equal than
        90.

        Set the gap with of the column and bar series chart by 'gap_width'
        property. The 'gap_width' property is optional. The default width is
        150, and the value should be great or equal than 0 and less or equal
        than 500.

        Set series overlap of the column and bar series chart by 'overlap'
        property. The 'overlap' property is optional. The default width is 0,
        and the value should be great or equal than -100 and less or equal than
        100.

        combo: Specifies the create a chart that combines two or more chart
        types in a single chart.

        Example:
            For example, create 3D clustered column chart with data
            Sheet1!$E$1:$L$15:

            ```python
            import excelize

            f = excelize.new_file()
            data = [
                [None, "Apple", "Orange", "Pear"],
                ["Small", 2, 3, 3],
                ["Normal", 5, 2, 4],
                ["Large", 6, 7, 8],
            ]
            try:
                for idx, row in enumerate(data):
                    cell = excelize.coordinates_to_cell_name(1, idx + 1, False)
                    f.set_sheet_row("Sheet1", cell, row)
                chart = excelize.Chart(
                    type=excelize.ChartType.Col3DClustered,
                    series=[
                        excelize.ChartSeries(
                            name="Sheet1!$A$2",
                            categories="Sheet1!$B$1:$D$1",
                            values="Sheet1!$B$2:$D$2",
                        ),
                        excelize.ChartSeries(
                            name="Sheet1!$A$3",
                            categories="Sheet1!$B$1:$D$1",
                            values="Sheet1!$B$3:$D$3",
                        ),
                        excelize.ChartSeries(
                            name="Sheet1!$A$4",
                            categories="Sheet1!$B$1:$D$1",
                            values="Sheet1!$B$4:$D$4",
                        ),
                    ],
                    title=[excelize.RichTextRun(text="Fruit 3D Clustered Column Chart")],
                )
                f.add_chart("Sheet1", "E1", chart)
                # Save spreadsheet by the given path.
                f.save_as("Book1.xlsx")
            except (RuntimeError, TypeError) as err:
                print(err)
            finally:
                err = f.close()
                if err:
                    print(err)
            ```

            For example, create a clustered column - line chart with data
            Sheet1!$E$1:$L$15:

            ```python
            import excelize

            f = excelize.new_file()
            try:
                for idx, row in enumerate(
                    [
                        [None, "Apple", "Orange", "Pear"],
                        ["Small", 2, 3, 3],
                        ["Normal", 5, 2, 4],
                        ["Large", 6, 7, 8],
                    ]
                ):
                    cell = excelize.coordinates_to_cell_name(1, idx + 1)
                    f.set_sheet_row("Sheet1", cell, row)

                f.add_chart(
                    "Sheet1",
                    "E1",
                    excelize.Chart(
                        type=excelize.ChartType.Col,
                        series=[
                            excelize.ChartSeries(
                                name="Sheet1!$A$2",
                                categories="Sheet1!$B$1:$D$1",
                                values="Sheet1!$B$2:$D$2",
                            )
                        ],
                        format=excelize.GraphicOptions(
                            scale_x=1,
                            scale_y=1,
                            offset_x=15,
                            offset_y=10,
                            print_object=True,
                            lock_aspect_ratio=False,
                            locked=False,
                        ),
                        title=[
                            excelize.RichTextRun(
                                text="Clustered Column - Line Chart",
                            )
                        ],
                        legend=excelize.ChartLegend(position="left"),
                        plot_area=excelize.ChartPlotArea(
                            show_cat_name=False,
                            show_leader_lines=False,
                            show_percent=True,
                            show_ser_name=True,
                            show_val=True,
                        ),
                    ),
                    combo=excelize.Chart(
                        type=excelize.ChartType.Line,
                        series=[
                            excelize.ChartSeries(
                                name="Sheet1!$A$4",
                                categories="Sheet1!$B$1:$D$1",
                                values="Sheet1!$B$4:$D$4",
                                marker=excelize.ChartMarker(
                                    symbol="none",
                                    size=10,
                                ),
                            )
                        ],
                        format=excelize.GraphicOptions(
                            scale_x=1,
                            scale_y=1,
                            offset_x=15,
                            offset_y=10,
                            print_object=True,
                            lock_aspect_ratio=False,
                            locked=False,
                        ),
                        legend=excelize.ChartLegend(position="right"),
                        plot_area=excelize.ChartPlotArea(
                            show_cat_name=False,
                            show_leader_lines=False,
                            show_percent=True,
                            show_ser_name=True,
                            show_val=True,
                        ),
                    ),
                )
                # Save the spreadsheet by the given path.
                f.save_as("Book1.xlsx")
            except (RuntimeError, TypeError) as err:
                print(err)
            finally:
                err = f.close()
                if err:
                    print(err)
            ```
        """
        lib.AddChart.restype = c_char_p
        opts = [chart] + list(combo.values())
        charts = (types_go._Chart * len(opts))()
        for i, opt in enumerate(opts):
            charts[i] = py_value_to_c(opt, types_go._Chart())
        err = lib.AddChart(
            self.file_index,
            sheet.encode(ENCODE),
            cell.encode(ENCODE),
            byref(charts),
            len(charts),
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def add_chart_sheet(self, sheet: str, chart: Chart, **combo: Chart) -> None:
        """
        Create a chartsheet by given chart format set (such as offset, scale,
        aspect ratio setting and print settings) and properties set. In Excel a
        chartsheet is a worksheet that only contains a chart.

        Args:
            sheet (str): The worksheet name
            chart (Chart): Chart options
            **combo (Chart): Optional parameters for combo chart

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        lib.AddChartSheet.restype = c_char_p
        opts = [chart] + list(combo.values())
        charts = (types_go._Chart * len(opts))()
        for i, opt in enumerate(opts):
            charts[i] = py_value_to_c(opt, types_go._Chart())
        err = lib.AddChartSheet(
            self.file_index,
            sheet.encode(ENCODE),
            byref(charts),
            len(charts),
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def add_comment(self, sheet: str, opts: Comment) -> None:
        """
        Add comments in a sheet by giving the worksheet name, cell reference,
        and format set (such as author and text). Note that the maximum author
        name length is 255 and the max text length is 32512.

        Args:
            sheet (str): The worksheet name
            opts (Comment): The comment options

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            For example, add a rich-text comment with a specified comments box
            size in Sheet1!A5:

            ```python
            try:
                f.add_comment("Sheet1", excelize.Comment(
                    cell="A5",
                    author="Excelize",
                    paragraph=[
                        excelize.RichTextRun(text="Excelize: ", font=excelize.Font(bold=True)),
                        excelize.RichTextRun(text="This is a comment."),
                    ],
                    height=40,
                    width=180,
                ))
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        lib.AddComment.restype = c_char_p
        options = py_value_to_c(opts, types_go._Comment())
        err = lib.AddComment(
            self.file_index, sheet.encode(ENCODE), byref(options)
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def add_form_control(self, sheet: str, opts: FormControl) -> None:
        """
        Add form control object in a worksheet by given worksheet name and form
        control options. Supported form control type: button, check box, group
        box, label, option button, scroll bar and spinner. If set macro for the
        form control, the workbook extension should be XLSM or XLTM. Scroll
        value must be between 0 and 30000. Please note that if a cell link is
        set for a checkbox form control, Excelize will not assign a value to the
        linked cell when the checkbox is checked. To reflect the checkbox state,
        please use the `set_cell_value` function to manually set the linked
        cell's value to true.

        Args:
            sheet (str): The worksheet name
            opts (FormControl): The form control options

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            Example 1, add button form control with macro, rich-text, custom
            button size, print property on Sheet1!A2, and let the button do not
            move or size with cells:

            ```python
            try:
                f.add_form_control(
                    "Sheet1",
                    excelize.FormControl(
                        cell="A2",
                        type=excelize.FormControlType.FormControlButton,
                        macro="Button1_Click",
                        width=140,
                        height=60,
                        text="Button 1\r\n",
                        paragraph=[
                            excelize.RichTextRun(
                                font=excelize.Font(
                                    bold=True,
                                    italic=True,
                                    underline="single",
                                    family="Times New Roman",
                                    size=14,
                                    color="777777",
                                ),
                                text="C1=A1+B1",
                            ),
                        ],
                        format=excelize.GraphicOptions(
                            print_object=True,
                            positioning="absolute",
                        ),
                    ),
                )
            except (RuntimeError, TypeError) as err:
                print(err)
            ```

            Example 2, add option button form control with checked status and
            text on Sheet1!A1:

            ```python
            try:
                f.add_form_control(
                    "Sheet1",
                    excelize.FormControl(
                        cell="A2",
                        type=excelize.FormControlType.FormControlOptionButton,
                        text="Option Button 1",
                        checked=True,
                    ),
                )
            except (RuntimeError, TypeError) as err:
                print(err)
            ```

            Example 3, add spin button form control on Sheet1!B1 to increase or
            decrease the value of Sheet1!A1:

            ```python
            try:
                f.add_form_control(
                    "Sheet1",
                    excelize.FormControl(
                        cell="B1",
                        type=excelize.FormControlType.FormControlSpinButton,
                        width=15,
                        height=40,
                        current_val=7,
                        min_val=5,
                        max_val=10,
                        inc_change=1,
                        cell_link="A1",
                    ),
                )
            except (RuntimeError, TypeError) as err:
                print(err)
            ```

            Example 4, add horizontally scroll bar form control on Sheet1!A2 to
            change  the value of Sheet1!A1 by click the scroll arrows or drag
            the scroll box:

            ```python
            try:
                f.add_form_control(
                    "Sheet1",
                    excelize.FormControl(
                        cell="A2",
                        type=excelize.FormControlType.FormControlScrollBar,
                        width=140,
                        height=20,
                        current_val=50,
                        min_val=10,
                        max_val=100,
                        inc_change=1,
                        page_change=1,
                        cell_link="A1",
                        horizontally=True,
                    ),
                )
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        lib.AddFormControl.restype = c_char_p
        options = py_value_to_c(opts, types_go._FormControl())
        err = lib.AddFormControl(
            self.file_index, sheet.encode(ENCODE), byref(options)
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def add_picture(
        self, sheet: str, cell: str, name: str, opts: Optional[GraphicOptions]
    ) -> None:
        """
        Add picture in a sheet by given picture format set (such as offset,
        scale, aspect ratio setting and print settings) and file path. Supported
        image types: GIF, JPEG, JPG, PNG, TIF and TIFF. Note that this function
        only supports adding pictures placed over the cells currently, and
        doesn't support adding pictures placed in cells or creating the Kingsoft
        WPS Office embedded image cells.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference
            name (str): The image file path
            *opts (GraphicOptions): The image options

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            For example:

            ```python
            import excelize

            try:
                f = excelize.new_file()
            except (RuntimeError, TypeError) as err:
                print(err)
                exit()
            try:
                # Insert a picture.
                f.add_picture("Sheet1", "A2", "image.png", None)
                # Insert a picture to worksheet with scaling.
                f.add_picture("Sheet1", "D2", "image.jpg", excelize.GraphicOptions(
                    scale_x=0.5,
                    scale_y=0.5,
                ))
                # Insert a picture offset in the cell with printing support.
                f.add_picture("Sheet1", "H2", "image.gif", excelize.GraphicOptions(
                    offset_x=15,
                    offset_y=10,
                    hyperlink="https://github.com/xuri/excelize",
                    hyperlink_type="External",
                    print_object=True,
                    lock_aspect_ratio=False,
                    locked=False,
                    positioning="oneCell",
                ))
                # Save the spreadsheet with the origin path.
                f.save_as("Book1.xlsx")
            except (RuntimeError, TypeError) as err:
                print(err)
            finally:
                # Close the spreadsheet.
                err = f.close()
                if err:
                    print(err)
            ```
        """
        lib.AddPicture.restype = c_char_p
        options = (
            byref(py_value_to_c(opts, types_go._GraphicOptions()))
            if opts
            else POINTER(types_go._GraphicOptions)()
        )
        err = lib.AddPicture(
            self.file_index,
            sheet.encode(ENCODE),
            cell.encode(ENCODE),
            name.encode(ENCODE),
            options,
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def add_picture_from_bytes(self, sheet: str, cell: str, picture: Picture) -> None:
        """
        Add picture in a sheet by given picture format set (such as offset,
        scale, aspect ratio setting and print settings), file base name,
        extension name and file bytes. Supported image types:  GIF, JPEG, JPG,
        PNG, TIF and TIFF. Note that this function only supports adding pictures
        placed over the cells currently, and doesn't support adding pictures
        placed in cells or creating the Kingsoft WPS Office embedded image
        cells.

        Args:
            sheet (str): The worksheet name
            extension (str): The image extension
            picture (Picture): The picture options

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            For example:

            ```python
            import excelize

            try:
                f = excelize.new_file()
            except (RuntimeError, TypeError) as err:
                print(err)
                exit()
            try:
                with open("image.jpg", "rb") as file:
                    f.add_picture_from_bytes(
                        "Sheet1",
                        "A2",
                        excelize.Picture(
                            extension=".jpg",
                            file=file.read(),
                            format=excelize.GraphicOptions(alt_text="Excel Logo"),
                        ),
                    )
                f.save_as("Book1.xlsx")
            except (RuntimeError, TypeError) as err:
                print(err)
            finally:
                err = f.close()
                if err:
                    print(err)
            ```
        """
        lib.AddPictureFromBytes.restype = c_char_p
        err = lib.AddPictureFromBytes(
            self.file_index,
            sheet.encode(ENCODE),
            cell.encode(ENCODE),
            byref(py_value_to_c(picture, types_go._Picture())),
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def add_pivot_table(self, opts: Optional[PivotTableOptions]) -> None:
        """
        Add pivot table by given pivot table options. Note that the same fields
        can not in Columns, Rows and Filter fields at the same time.

        Args:
            opts (PivotTableOptions): The pivot table options

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            For example, create a pivot table on the range reference
            Sheet1!G2:M34 with the range reference Sheet1!A1:E31 as the data
            source, summarize by sum for sales:

            ```python
            import excelize
            import random

            f = excelize.new_file()
            month = [
                "Jan", "Feb", "Mar", "Apr", "May", "Jun",
                "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
            ]
            year = [2017, 2018, 2019]
            types = ["Meat", "Dairy", "Beverages", "Produce"]
            region = ["East", "West", "North", "South"]
            try:
                f.set_sheet_row("Sheet1", "A1", ["Month", "Year", "Type", "Sales", "Region"])
                for row in range(2, 32):
                    f.set_cell_value("Sheet1", f"A{row}", month[random.randrange(12)])
                    f.set_cell_value("Sheet1", f"B{row}", year[random.randrange(3)])
                    f.set_cell_value("Sheet1", f"C{row}", types[random.randrange(4)])
                    f.set_cell_value("Sheet1", f"D{row}", random.randrange(5000))
                    f.set_cell_value("Sheet1", f"E{row}", region[random.randrange(4)])

                f.add_pivot_table(
                    excelize.PivotTableOptions(
                        data_range="Sheet1!A1:E31",
                        pivot_table_range="Sheet1!G2:M34",
                        rows=[
                            excelize.PivotTableField(data="Month", default_subtotal=True),
                            excelize.PivotTableField(data="Year"),
                        ],
                        filter=[excelize.PivotTableField(data="Region")],
                        columns=[
                            excelize.PivotTableField(data="Type", default_subtotal=True),
                        ],
                        data=[
                            excelize.PivotTableField(data="Sales", name="Summarize", subtotal="Sum"),
                        ],
                        row_grand_totals=True,
                        col_grand_totals=True,
                        show_drill=True,
                        show_row_headers=True,
                        show_col_headers=True,
                        show_last_column=True,
                    )
                )
                f.save_as("Book1.xlsx")
            except (RuntimeError, TypeError) as err:
                print(err)
            finally:
                err = f.close()
                if err:
                    print(err)
            ```
        """
        lib.AddPivotTable.restype = c_char_p
        err = lib.AddPivotTable(
            self.file_index,
            byref(py_value_to_c(opts, types_go._PivotTableOptions())),
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def add_shape(self, sheet: str, opts: Shape) -> None:
        """
        Add shape in a sheet by given worksheet name and shape format set (such
        as offset, scale, aspect ratio setting and print settings).

        Args:
            sheet (str): The worksheet name
            opts (Shape): The shape options

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        The following shows the type of shape supported by excelize:

        | Type                             | Shape                                      |
        |----------------------------------|--------------------------------------------|
        | accentBorderCallout1             | Callout 1 with Border and Accent Shape     |
        | accentBorderCallout2             | Callout 2 with Border and Accent Shape     |
        | accentBorderCallout3             | Callout 3 with Border and Accent Shape     |
        | accentCallout1                   | Callout 1 Shape                            |
        | accentCallout2                   | Callout 2 Shape                            |
        | accentCallout3                   | Callout 3 Shape                            |
        | actionButtonBackPrevious         | Back or Previous Button Shape              |
        | actionButtonBeginning            | Beginning Button Shape                     |
        | actionButtonBlank                | Blank Button Shape                         |
        | actionButtonDocument             | Document Button Shape                      |
        | actionButtonEnd                  | End Button Shape                           |
        | actionButtonForwardNext          | Forward or Next Button Shape               |
        | actionButtonHelp                 | Help Button Shape                          |
        | actionButtonHome                 | Home Button Shape                          |
        | actionButtonInformation          | Information Button Shape                   |
        | actionButtonMovie                | Movie Button Shape                         |
        | actionButtonReturn               | Return Button Shape                        |
        | actionButtonSound                | Sound Button Shape                         |
        | arc                              | Curved Arc Shape                           |
        | bentArrow                        | Bent Arrow Shape                           |
        | bentConnector2                   | Bent Connector 2 Shape                     |
        | bentConnector3                   | Bent Connector 3 Shape                     |
        | bentConnector4                   | Bent Connector 4 Shape                     |
        | bentConnector5                   | Bent Connector 5 Shape                     |
        | bentUpArrow                      | Bent Up Arrow Shape                        |
        | bevel                            | Bevel Shape                                |
        | blockArc                         | Block Arc Shape                            |
        | borderCallout1                   | Callout 1 with Border Shape                |
        | borderCallout2                   | Callout 2 with Border Shape                |
        | borderCallout3                   | Callout 3 with Border Shape                |
        | bracePair                        | Brace Pair Shape                           |
        | bracketPair                      | Bracket Pair Shape                         |
        | callout1                         | Callout 1 Shape                            |
        | callout2                         | Callout 2 Shape                            |
        | callout3                         | Callout 3 Shape                            |
        | can                              | Can Shape                                  |
        | chartPlus                        | Chart Plus Shape                           |
        | chartStar                        | Chart Star Shape                           |
        | chartX                           | Chart X Shape                              |
        | chevron                          | Chevron Shape                              |
        | chord                            | Chord Shape                                |
        | circularArrow                    | Circular Arrow Shape                       |
        | cloud                            | Cloud Shape                                |
        | cloudCallout                     | Callout Cloud Shape                        |
        | corner                           | Corner Shape                               |
        | cornerTabs                       | Corner Tabs Shape                          |
        | cube                             | Cube Shape                                 |
        | curvedConnector2                 | Curved Connector 2 Shape                   |
        | curvedConnector3                 | Curved Connector 3 Shape                   |
        | curvedConnector4                 | Curved Connector 4 Shape                   |
        | curvedConnector5                 | Curved Connector 5 Shape                   |
        | curvedDownArrow                  | Curved Down Arrow Shape                    |
        | curvedLeftArrow                  | Curved Left Arrow Shape                    |
        | curvedRightArrow                 | Curved Right Arrow Shape                   |
        | curvedUpArrow                    | Curved Up Arrow Shape                      |
        | decagon                          | Decagon Shape                              |
        | diagStripe                       | Diagonal Stripe Shape                      |
        | diamond                          | Diamond Shape                              |
        | dodecagon                        | Dodecagon Shape                            |
        | donut                            | Donut Shape                                |
        | doubleWave                       | Double Wave Shape                          |
        | downArrow                        | Down Arrow Shape                           |
        | downArrowCallout                 | Callout Down Arrow Shape                   |
        | ellipse                          | Ellipse Shape                              |
        | ellipseRibbon                    | Ellipse Ribbon Shape                       |
        | ellipseRibbon2                   | Ellipse Ribbon 2 Shape                     |
        | flowChartAlternateProcess        | Alternate Process Flow Shape               |
        | flowChartCollate                 | Collate Flow Shape                         |
        | flowChartConnector               | Connector Flow Shape                       |
        | flowChartDecision                | Decision Flow Shape                        |
        | flowChartDelay                   | Delay Flow Shape                           |
        | flowChartDisplay                 | Display Flow Shape                         |
        | flowChartDocument                | Document Flow Shape                        |
        | flowChartExtract                 | Extract Flow Shape                         |
        | flowChartInputOutput             | Input Output Flow Shape                    |
        | flowChartInternalStorage         | Internal Storage Flow Shape                |
        | flowChartMagneticDisk            | Magnetic Disk Flow Shape                   |
        | flowChartMagneticDrum            | Magnetic Drum Flow Shape                   |
        | flowChartMagneticTape            | Magnetic Tape Flow Shape                   |
        | flowChartManualInput             | Manual Input Flow Shape                    |
        | flowChartManualOperation         | Manual Operation Flow Shape                |
        | flowChartMerge                   | Merge Flow Shape                           |
        | flowChartMultidocument           | Multi-Document Flow Shape                  |
        | flowChartOfflineStorage          | Offline Storage Flow Shape                 |
        | flowChartOffpageConnector        | Off-Page Connector Flow Shape              |
        | flowChartOnlineStorage           | Online Storage Flow Shape                  |
        | flowChartOr                      | Or Flow Shape                              |
        | flowChartPredefinedProcess       | Predefined Process Flow Shape              |
        | flowChartPreparation             | Preparation Flow Shape                     |
        | flowChartProcess                 | Process Flow Shape                         |
        | flowChartPunchedCard             | Punched Card Flow Shape                    |
        | flowChartPunchedTape             | Punched Tape Flow Shape                    |
        | flowChartSort                    | Sort Flow Shape                            |
        | flowChartSummingJunction         | Summing Junction Flow Shape                |
        | flowChartTerminator              | Terminator Flow Shape                      |
        | foldedCorner                     | Folded Corner Shape                        |
        | frame                            | Frame Shape                                |
        | funnel                           | Funnel Shape                               |
        | gear6                            | Gear 6 Shape                               |
        | gear9                            | Gear 9 Shape                               |
        | halfFrame                        | Half Frame Shape                           |
        | heart                            | Heart Shape                                |
        | heptagon                         | Heptagon Shape                             |
        | hexagon                          | Hexagon Shape                              |
        | homePlate                        | Home Plate Shape                           |
        | horizontalScroll                 | Horizontal Scroll Shape                    |
        | irregularSeal1                   | Irregular Seal 1 Shape                     |
        | irregularSeal2                   | Irregular Seal 2 Shape                     |
        | leftArrow                        | Left Arrow Shape                           |
        | leftArrowCallout                 | Callout Left Arrow Shape                   |
        | leftBrace                        | Left Brace Shape                           |
        | leftBracket                      | Left Bracket Shape                         |
        | leftCircularArrow                | Left Circular Arrow Shape                  |
        | leftRightArrow                   | Left Right Arrow Shape                     |
        | leftRightArrowCallout            | Callout Left Right Arrow Shape             |
        | leftRightCircularArrow           | Left Right Circular Arrow Shape            |
        | leftRightRibbon                  | Left Right Ribbon Shape                    |
        | leftRightUpArrow                 | Left Right Up Arrow Shape                  |
        | leftUpArrow                      | Left Up Arrow Shape                        |
        | lightningBolt                    | Lightning Bolt Shape                       |
        | line                             | Line Shape                                 |
        | lineInv                          | Line Inverse Shape                         |
        | mathDivide                       | Divide Math Shape                          |
        | mathEqual                        | Equal Math Shape                           |
        | mathMinus                        | Minus Math Shape                           |
        | mathMultiply                     | Multiply Math Shape                        |
        | mathNotEqual                     | Not Equal Math Shape                       |
        | mathPlus                         | Plus Math Shape                            |
        | moon                             | Moon Shape                                 |
        | nonIsoscelesTrapezoid            | Non-Isosceles Trapezoid Shape              |
        | noSmoking                        | No Smoking Shape                           |
        | notchedRightArrow                | Notched Right Arrow Shape                  |
        | octagon                          | Octagon Shape                              |
        | parallelogram                    | Parallelogram Shape                        |
        | pentagon                         | Pentagon Shape                             |
        | pie                              | Pie Shape                                  |
        | pieWedge                         | Pie Wedge Shape                            |
        | plaque                           | Plaque Shape                               |
        | plaqueTabs                       | Plaque Tabs Shape                          |
        | plus                             | Plus Shape                                 |
        | quadArrow                        | Quad-Arrow Shape                           |
        | quadArrowCallout                 | Callout Quad-Arrow Shape                   |
        | rect                             | Rectangle Shape                            |
        | ribbon                           | Ribbon Shape                               |
        | ribbon2                          | Ribbon 2 Shape                             |
        | rightArrow                       | Right Arrow Shape                          |
        | rightArrowCallout                | Callout Right Arrow Shape                  |
        | rightBrace                       | Right Brace Shape                          |
        | rightBracket                     | Right Bracket Shape                        |
        | round1Rect                       | One Round Corner Rectangle Shape           |
        | round2DiagRect                   | Two Diagonal Round Corner Rectangle Shape  |
        | round2SameRect                   | Two Same-side Round Corner Rectangle Shape |
        | roundRect                        | Round Corner Rectangle Shape               |
        | rtTriangle                       | Right Triangle Shape                       |
        | smileyFace                       | Smiley Face Shape                          |
        | snip1Rect                        | One Snip Corner Rectangle Shape            |
        | snip2DiagRect                    | Two Diagonal Snip Corner Rectangle Shape   |
        | snip2SameRect                    | Two Same-side Snip Corner Rectangle Shape  |
        | snipRoundRect                    | One Snip One Round Corner Rectangle Shape  |
        | squareTabs                       | Square Tabs Shape                          |
        | star10                           | Ten Pointed Star Shape                     |
        | star12                           | Twelve Pointed Star Shape                  |
        | star16                           | Sixteen Pointed Star Shape                 |
        | star24                           | Twenty Four Pointed Star Shape             |
        | star32                           | Thirty Two Pointed Star Shape              |
        | star4                            | Four Pointed Star Shape                    |
        | star5                            | Five Pointed Star Shape                    |
        | star6                            | Six Pointed Star Shape                     |
        | star7                            | Seven Pointed Star Shape                   |
        | star8                            | Eight Pointed Star Shape                   |
        | straightConnector1               | Straight Connector 1 Shape                 |
        | stripedRightArrow                | Striped Right Arrow Shape                  |
        | sun                              | Sun Shape                                  |
        | swooshArrow                      | Swoosh Arrow Shape                         |
        | teardrop                         | Teardrop Shape                             |
        | trapezoid                        | Trapezoid Shape                            |
        | triangle                         | Triangle Shape                             |
        | upArrow                          | Up Arrow Shape                             |
        | upArrowCallout                   | Callout Up Arrow Shape                     |
        | upDownArrow                      | Up Down Arrow Shape                        |
        | upDownArrowCallout               | Callout Up Down Arrow Shape                |
        | uturnArrow                       | U-Turn Arrow Shape                         |
        | verticalScroll                   | Vertical Scroll Shape                      |
        | wave                             | Wave Shape                                 |
        | wedgeEllipseCallout              | Callout Wedge Ellipse Shape                |
        | wedgeRectCallout                 | Callout Wedge Rectangle Shape              |
        | wedgeRoundRectCallout            | Callout Wedge Round Rectangle Shape        |


        The following shows the type of text underline supported by excelize:

            none
            words
            sng
            dbl
            heavy
            dotted
            dottedHeavy
            dash
            dashHeavy
            dashLong
            dashLongHeavy
            dotDash
            dotDashHeavy
            dotDotDash
            dotDotDashHeavy
            wavy
            wavyHeavy
            wavyDbl

        Example:
            For example, add text box (rect shape) in Sheet1:

            ```python
            import excelize

            f = excelize.new_file()
            try:
                f.add_shape(
                    "Sheet1",
                    excelize.Shape(
                        cell="G6",
                        type="rect",
                        line=excelize.ShapeLine(
                            color="4286F4",
                            width=1.2,
                        ),
                        fill=excelize.Fill(
                            color=["8EB9FF"],
                            pattern=1,
                        ),
                        paragraph=[
                            excelize.RichTextRun(
                                text="Rectangle Shape",
                                font=excelize.Font(
                                    bold=True,
                                    italic=True,
                                    family="Times New Roman",
                                    size=19,
                                    color="777777",
                                    underline="sng",
                                ),
                            )
                        ],
                        width=80,
                        height=40,
                    ),
                )
                f.save_as("Book1.xlsx")
            except (RuntimeError, TypeError) as err:
                print(err)
            finally:
                err = f.close()
                if err:
                    print(err)
            ```
        """
        lib.AddShape.restype = c_char_p
        options = py_value_to_c(opts, types_go._Shape())
        err = lib.AddShape(
            self.file_index, sheet.encode(ENCODE), byref(options)
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def add_slicer(self, sheet: str, opts: SlicerOptions) -> None:
        """
        Inserts a slicer by giving the worksheet name and slicer settings.

        Args:
            sheet (str): The worksheet name
            opts (SlicerOptions): The slicer options

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            For example, insert a slicer on the Sheet1!E1 with field Column1 for
            the table named Table1:

            ```python
            try:
                f.add_slicer(
                    "Sheet1",
                    excelize.SlicerOptions(
                        name="Column1",
                        cell="E1",
                        table_sheet="Sheet1",
                        table_name="Table1",
                        caption="Column1",
                        width=200,
                        height=200,
                    ),
                )
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        lib.AddSlicer.restype = c_char_p
        options = py_value_to_c(opts, types_go._SlicerOptions())
        err = lib.AddSlicer(
            self.file_index, sheet.encode(ENCODE), byref(options)
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def add_sparkline(self, sheet: str, opts: SparklineOptions) -> None:
        """
        Add sparklines to the worksheet by given formatting options. Sparklines
        are small charts that fit in a single cell and are used to show trends
        in data. Sparklines are a feature of Excel 2010 and later only. You can
        write them to workbook that can be read by Excel 2007, but they won't be
        displayed.

        Args:
            sheet (str): The worksheet name
            opts (SparklineOptions): The sparklines options

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        The following shows the formatting options of sparkline supported by
        excelize:

        | Parameter   | Description                                                   |
        |-------------|---------------------------------------------------------------|
        | Location    | Required, must have the same number with 'range' parameter    |
        | Range       | Required, must have the same number with 'location' parameter |
        | Type        | Enumeration value: line, column, win_loss                     |
        | Style       | Value range: 0 - 35                                           |
        | Hight       | Toggle sparkline high points                                  |
        | Low         | Toggle sparkline low points                                   |
        | First       | Toggle sparkline first points                                 |
        | Last        | Toggle sparkline last points                                  |
        | Negative    | Toggle sparkline negative points                              |
        | Markers     | Toggle sparkline markers                                      |
        | Axis        | Used to specify if show horizontal axis                       |
        | Reverse     | Used to specify if enable plot data right-to-left             |
        | SeriesColor | An RGB Color is specified as RRGGBB                           |

        Example:
            For example, add a grouped sparkline. Changes are applied to all
            three:

            ```python
            try:
                f.add_sparkline(
                    "Sheet1",
                    excelize.SparklineOptions(
                        location=["A1", "A2", "A3"],
                        range=["Sheet2!A1:J1", "Sheet2!A2:J2", "Sheet2!A3:J3"],
                        markers=True,
                    ),
                )
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        lib.AddSparkline.restype = c_char_p
        options = py_value_to_c(opts, types_go._SparklineOptions())
        err = lib.AddSparkline(
            self.file_index, sheet.encode(ENCODE), byref(options)
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def add_table(self, sheet: str, table: Table) -> None:
        """
        Add table in a worksheet by given worksheet name, range reference and
        format set.

        Note that the table must be at least two lines including the header. The
        header cells must contain strings and must be unique, and must set the
        header row data of the table before calling the `add_table` function.
        Multiple tables range reference that can't have an intersection.

        Args:
            sheet (str): The worksheet name
            table (Table): The table options

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            For example, create a table of A1:D5 on Sheet1:

            ```python
            try:
                f.add_table("Sheet1", excelize.Table(range="A1:D5"))
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        lib.AddTable.restype = c_char_p
        options = py_value_to_c(table, types_go._Table())
        err = lib.AddTable(
            self.file_index, sheet.encode(ENCODE), byref(options)
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def add_vba_project(self, file: bytes) -> None:
        """
        Add vbaProject.bin file which contains functions and/or macros. The file
        extension should be XLSM or XLTM.

        Args:
            file (bytes): The contents buffer of the file

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        lib.AddVBAProject.restype = c_char_p
        err = lib.AddVBAProject(
            self.file_index,
            cast(file, POINTER(c_ubyte)),
            len(file),
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def auto_filter(
        self,
        sheet: str,
        range_ref: str,
        opts: List[AutoFilterOptions],
    ) -> None:
        """
        Add auto filter in a worksheet by given worksheet name, range reference
        and settings. An auto filter in Excel is a way of filtering a 2D range
        of data based on some simple criteria.

        Column defines the filter columns in an auto filter range based on
        simple criteria.

        It isn't sufficient to just specify the filter condition. You must also
        hide any rows that don't match the filter condition. Rows are hidden
        using the `set_row_visible` function. Excelize can't filter rows
        automatically since this isn't part of the file format.

        Args:
            sheet (str): The worksheet name
            range_ref (str): The top-left and right-bottom cell range reference
            opts (List[AutoFilterOptions]): The auto filter options

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        lib.AutoFilter.restype = c_char_p
        options = (types_go._AutoFilterOptions * len(opts))()
        for i, opt in enumerate(opts):
            options[i] = py_value_to_c(opt, types_go._AutoFilterOptions())
        err = lib.AutoFilter(
            self.file_index,
            sheet.encode(ENCODE),
            range_ref.encode(ENCODE),
            byref(options),
            len(options),
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def calc_cell_value(self, sheet: str, cell: str, *opts: Options) -> str:
        """
        Get calculated cell value. This feature is currently in working
        processing. Iterative calculation, implicit intersection, explicit
        intersection, array formula, table formula and some other formulas are
        not supported currently.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference
            *opts (Options): Optional parameters for get cell value

        Returns:
            str: Return the calculation result as a string if no
            error occurred, otherwise raise a RuntimeError with the message.
        """
        lib.CalcCellValue.restype = types_go._StringErrorResult
        options = (
            byref(py_value_to_c(opts[0], types_go._Options()))
            if opts
            else POINTER(types_go._Options)()
        )
        res = lib.CalcCellValue(
            self.file_index, sheet.encode(ENCODE), cell.encode(ENCODE), options
        )
        err = res.err.decode(ENCODE)
        if not err:
            return res.val.decode(ENCODE)
        raise RuntimeError(err)

    def close(self) -> Optional[Exception]:
        """
        Closes and cleanup the open temporary file for the spreadsheet.

        Returns:
            Optional[Exception]: Returns None if no error occurred,
            otherwise returns an Exception with the message.
        """
        err, lib.Close.restype = None, c_char_p
        err = lib.Close(self.file_index).decode(ENCODE)
        return None if err == "" else Exception(err)

    def copy_sheet(self, src: int, to: int) -> None:
        """
        Duplicate a worksheet by gave source and target worksheet index. Note
        that currently doesn't support duplicate workbooks that contain tables,
        charts or pictures.

        Args:
            src (int): Source sheet index
            to (int): Target sheet index

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            For example:

            ```python
            try:
                # Sheet1 already exists...
                index = f.new_sheet("Sheet2")
                f.copy_sheet(0, index)
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        err, lib.CopySheet.restype = None, c_char_p
        err = lib.CopySheet(self.file_index, src, to).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def delete_chart(self, sheet: str, cell: str) -> None:
        """
        Delete chart in spreadsheet by given worksheet name and cell reference.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        err, lib.DeleteChart.restype = None, c_char_p
        err = lib.DeleteChart(
            self.file_index, sheet.encode(ENCODE), cell.encode(ENCODE)
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def delete_comment(self, sheet: str, cell: str) -> None:
        """
        Delete comment in a worksheet by given worksheet name and cell reference.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            For example, delete the comment in Sheet1!$A$30:

            ```python
            f.delete_comment("Sheet1", "A30")
            ```
        """
        err, lib.DeleteComment.restype = None, c_char_p
        err = lib.DeleteComment(
            self.file_index, sheet.encode(ENCODE), cell.encode(ENCODE)
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def delete_defined_name(self, defined_name: DefinedName) -> None:
        """
        Delete the defined names of the workbook or worksheet. If not specified
        scope, the default scope is workbook.

        Args:
            defined_name (DefinedName): The defined name options

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            For example:

            ```python
            try:
                f.delete_defined_name(excelize.DefinedName(
                    name="Amount",
                    scope="Sheet2",
                ))
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        lib.DeleteDefinedName.restype = c_char_p
        options = py_value_to_c(defined_name, types_go._DefinedName())
        err = lib.DeleteDefinedName(self.file_index, byref(options)).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def delete_picture(self, sheet: str, cell: str) -> None:
        """
        Delete all pictures in a cell by given worksheet name and cell reference.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        err, lib.DeletePicture.restype = None, c_char_p
        err = lib.DeletePicture(
            self.file_index, sheet.encode(ENCODE), cell.encode(ENCODE)
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def delete_sheet(self, sheet: str) -> None:
        """
        Delete worksheet in a workbook by given worksheet name. Use this method
        with caution, which will affect changes in references such as formulas,
        charts, and so on. If there is any referenced value of the deleted
        worksheet, it will cause a file error when you open it. This function
        will be invalid when only one worksheet is left.

        Args:
            sheet (str): The worksheet name

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        err, lib.DeleteSheet.restype = None, c_char_p
        err = lib.DeleteSheet(self.file_index, sheet.encode(ENCODE)).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def delete_slicer(self, name: str) -> None:
        """
        Delete a slicer by a given slicer name.

        Args:
            name (str): The slicer name

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        err, lib.DeleteSlicer.restype = None, c_char_p
        err = lib.DeleteSlicer(self.file_index, name.encode(ENCODE)).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def duplicate_row(self, sheet: str, row: int) -> None:
        """
        Inserts a copy of specified row (by its Excel row number) below. Use
        this method with caution, which will affect changes in references such
        as formulas, charts, and so on. If there is any referenced value of the
        worksheet, it will cause a file error when you open it. The excelize
        only partially updates these references currently.

        Args:
            sheet (str): The worksheet name
            row (int): The row number

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            For example:

            ```python
            try:
                f.duplicate_row("Sheet1", 2)
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        err, lib.DuplicateRow.restype = None, c_char_p
        err = lib.DuplicateRow(self.file_index, sheet.encode(ENCODE), row).decode(
            ENCODE
        )
        if err != "":
            raise RuntimeError(err)

    def duplicate_row_to(self, sheet: str, row: int, row2: int) -> None:
        """
        Inserts a copy of specified row by it Excel number to specified row
        position moving down exists rows after target position. Use this method
        with caution, which will affect changes in references such as formulas,
        charts, and so on. If there is any referenced value of the worksheet, it
        will cause a file error when you open it. The excelize only partially
        updates these references currently.

        Args:
            sheet (str): The worksheet name
            row (int): The row number
            row2 (int): The row number

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            For example:

            ```python
            try:
                f.duplicate_row_to("Sheet1", 2, 7)
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        err, lib.DuplicateRowTo.restype = None, c_char_p
        err = lib.DuplicateRowTo(
            self.file_index, sheet.encode(ENCODE), row, row2
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def get_active_sheet_index(self) -> int:
        """
        Get active sheet index of the spreadsheet. If not found the active sheet
        will be return integer 0.

        Returns:
            int: The active sheet index
        """
        lib.GetActiveSheetIndex.restype = c_int
        res = lib.GetActiveSheetIndex(self.file_index)
        return res

    def get_app_props(self) -> Optional[AppProperties]:
        """
        Get document application properties.

        Returns:
            Optional[AppProperties]: Return the app properties if no error
            occurred, otherwise raise a RuntimeError with the message.
        """
        lib.GetAppProps.restype = types_go._GetAppPropsResult
        res = lib.GetAppProps(self.file_index)
        err = res.err.decode(ENCODE)
        if not err:
            return c_value_to_py(res.opts, AppProperties())
        raise RuntimeError(err)

    def get_cell_formula(self, sheet: str, cell: str) -> str:
        """
        Get formula from cell by given worksheet name and cell reference in
        spreadsheet.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference

        Returns:
            str: Return the cell formula string and an exception if no
            error occurred, otherwise raise a RuntimeError with the message.
        """
        lib.GetCellFormula.restype = types_go._StringErrorResult
        res = lib.GetCellFormula(
            self.file_index, sheet.encode(ENCODE), cell.encode(ENCODE)
        )
        err = res.err.decode(ENCODE)
        if not err:
            return res.val.decode(ENCODE)
        raise RuntimeError(err)

    def get_cell_hyperlink(self, sheet: str, cell: str) -> Tuple[bool, str]:
        """
        Gets a cell hyperlink based on the given worksheet name and cell
        reference. If the cell has a hyperlink, it will return `True` and the
        link address, otherwise it will return `False` and an empty link address.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference

        Returns:
            Tuple[bool, str]: Return a tuple containing if the cell has a
            hyperlink and the link address if no error occurred, otherwise raise
            a RuntimeError with the message.

        Example:
            For example, get a hyperlink to a `H6` cell on a worksheet named
            `Sheet1`:

            ```python
            try:
                link, target = f.get_cell_hyperlink("Sheet1", "H6")
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        lib.GetCellHyperLink.restype = types_go._GetCellHyperLinkResult
        res = lib.GetCellHyperLink(
            self.file_index, sheet.encode(ENCODE), cell.encode(ENCODE)
        )
        err = res.err.decode(ENCODE)
        if not err:
            return (
                res.link,
                res.target.decode(ENCODE),
            )
        raise RuntimeError(err)

    def get_cell_style(self, sheet: str, cell: str) -> int:
        """
        Get cell style index by given worksheet name and cell reference.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference

        Returns:
            int:  Return the cell style ID if no error occurred, otherwise raise
            a RuntimeError with the message.
        """
        lib.GetCellStyle.restype = types_go._IntErrorResult
        res = lib.GetCellStyle(
            self.file_index, sheet.encode(ENCODE), cell.encode(ENCODE)
        )
        err = res.err.decode(ENCODE)
        if not err:
            return res.val
        raise RuntimeError(err)

    def get_cell_rich_text(self, sheet: str, cell: str) -> List[RichTextRun]:
        """
        Get rich text of cell by given worksheet and cell reference.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference

        Returns:
            List[RichTextRun]: Return rich text runs if no error occurred,
            otherwise raise a RuntimeError with the message.
        """
        lib.GetCellRichText.restype = types_go._GetCellRichTextResult
        res = lib.GetCellRichText(
            self.file_index, sheet.encode(ENCODE), cell.encode(ENCODE)
        )
        runs = c_value_to_py(res, GetCellRichTextResult()).runs
        err = res.Err.decode(ENCODE)
        if not err:
            return runs if runs else []
        raise RuntimeError(err)

    def get_cell_value(self, sheet: str, cell: str, *opts: Options) -> str:
        """
        Get formatted value from cell by given worksheet name and cell reference
        in spreadsheet. The return value is converted to the 'string' data type.
        If the cell format can be applied to the value of a cell, the applied
        value will be returned, otherwise the original value will be returned.
        All cells' values will be the same in a merged range.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference
            *opts (Options): Optional parameters for get cell value

        Returns:
            str: Return the cell value as a string if no error occurred,
            otherwise raise a RuntimeError with the message.
        """
        prepare_args(
            [sheet, cell, opts[0]] if opts else [sheet, cell],
            [
                argsRule("sheet", [str]),
                argsRule("cell", [str]),
                argsRule("opts", [Options], True),
            ],
        )
        lib.GetCellValue.restype = types_go._StringErrorResult
        options = (
            byref(py_value_to_c(opts[0], types_go._Options()))
            if opts
            else POINTER(types_go._Options)()
        )
        res = lib.GetCellValue(
            self.file_index, sheet.encode(ENCODE), cell.encode(ENCODE), options
        )
        err = res.err.decode(ENCODE)
        if not err:
            return res.val.decode(ENCODE)
        raise RuntimeError(err)

    def get_row_outline_level(self, sheet: str, row: int) -> int:
        """
        Get outline level of a single row by given worksheet name and row
        number.

        Args:
            sheet (str): The worksheet name
            row (int): The row number

        Returns:
            int: Return the row outline level if no error occurred, otherwise
            raise a RuntimeError with the message.

        Example:
            For example, get outline level of row 5 in Sheet1:

            ```python
            try:
                level = f.get_row_outline_level("Sheet1", 5)
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        lib.GetRowOutlineLevel.restype = types_go._IntErrorResult
        res = lib.GetRowOutlineLevel(self.file_index, sheet.encode(ENCODE), row)
        err = res.err.decode(ENCODE)
        if not err:
            return res.val
        raise RuntimeError(err)

    def get_row_height(self, sheet: str, row: int) -> float:
        """
        Get row height by given worksheet name and row number.

        Args:
            sheet (str): The worksheet name
            row (int): The row number

        Returns:
            float: Return the row height if no error occurred, otherwise
            raise a RuntimeError with the message.

        Example:
            For example, get height of row 5 in Sheet1:

            ```python
            try:
                height = f.get_row_height("Sheet1", 5)
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        lib.GetRowHeight.restype = types_go._Float64ErrorResult
        res = lib.GetRowHeight(self.file_index, sheet.encode(ENCODE), row)
        err = res.err.decode(ENCODE)
        if not err:
            return res.val
        raise RuntimeError(err)

    def get_col_outline_level(self, sheet: str, col: str) -> int:
        """
        Get outline level of a single column by given worksheet name and column
        name.

        Args:
            sheet (str): The worksheet name
            col (str): The column name

        Returns:
            int: Return the column outline level if no error occurred, otherwise
            raise a RuntimeError with the message.

        Example:
            For example, get outline level of column D in Sheet1:

            ```python
            try:
                level = f.get_col_outline_level("Sheet1", "D")
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        lib.GetColOutlineLevel.restype = types_go._IntErrorResult
        res = lib.GetColOutlineLevel(
            self.file_index, sheet.encode(ENCODE), col.encode(ENCODE)
        )
        err = res.err.decode(ENCODE)
        if not err:
            return res.val
        raise RuntimeError(err)

    def get_col_style(self, sheet: str, col: str) -> int:
        """
        Get column style ID by given worksheet name and column name.

        Args:
            sheet (str): The worksheet name
            col (str): The column name

        Returns:
            int: Return the column style ID if no error occurred, otherwise
            raise a RuntimeError with the message.
        """
        lib.GetColStyle.restype = types_go._IntErrorResult
        res = lib.GetColStyle(self.file_index, sheet.encode(ENCODE), col.encode(ENCODE))
        err = res.err.decode(ENCODE)
        if not err:
            return res.val
        raise RuntimeError(err)

    def get_col_visible(self, sheet: str, col: str) -> bool:
        """
        Get visible of a single column by given worksheet name and column name.

        Args:
            sheet (str): The worksheet name
            col (str): The column name

        Returns:
            bool: Return the column visible if no error occurred, otherwise
            raise a RuntimeError with the message.

        Example:
            For example, get visible state of column D in Sheet1:

            ```python
            try:
                visible = f.get_col_visible("Sheet1", "D")
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        lib.GetColVisible.restype = types_go._BoolErrorResult
        res = lib.GetColVisible(
            self.file_index, sheet.encode(ENCODE), col.encode(ENCODE)
        )
        err = res.err.decode(ENCODE)
        if not err:
            return res.val
        raise RuntimeError(err)

    def get_col_width(self, sheet: str, col: str) -> float:
        """
        Get column width by given worksheet name and column name.

        Args:
            sheet (str): The worksheet name
            col (str): The column name

        Returns:
            float: Return the column width if no error occurred, otherwise
            raise a RuntimeError with the message.

        Example:
            For example, get width of column D in Sheet1:

            ```python
            try:
                width = f.get_col_width("Sheet1", "D")
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        lib.GetColWidth.restype = types_go._Float64ErrorResult
        res = lib.GetColWidth(self.file_index, sheet.encode(ENCODE), col.encode(ENCODE))
        err = res.err.decode(ENCODE)
        if not err:
            return res.val
        raise RuntimeError(err)

    def get_comments(self, sheet: str) -> List[Comment]:
        """
        Retrieves all comments in a worksheet by given worksheet
        name.

        Returns:
            List[Comment]: Return the comment list if no error occurred,
            otherwise raise a RuntimeError with the message.
        """
        lib.GetComments.restype = types_go._GetCommentsResult
        res = lib.GetComments(self.file_index, sheet.encode(ENCODE))
        result = c_value_to_py(res, GetCommentsResult())
        if res.Err:
            err = res.Err.decode(ENCODE)
            if err:
                raise RuntimeError(err)
        return result.comments if result and result.comments else []

    def get_default_font(self) -> str:
        """
        Get the default font name currently set in the workbook. The spreadsheet
        generated by excelize default font is Calibri.

        Returns:
            str: Return the font name if no error occurred, otherwise raise
            a RuntimeError with the message.
        """
        lib.GetDefaultFont.restype = types_go._StringErrorResult
        res = lib.GetDefaultFont(self.file_index)
        err = res.err.decode(ENCODE)
        if not err:
            return res.val.decode(ENCODE)
        raise RuntimeError(err)

    def get_row_visible(self, sheet: str, row: int) -> bool:
        """
        Get visible of a single row by given worksheet name and Excel row number.

        Args:
            sheet (str): The worksheet name
            col (str): The column name

        Returns:
            bool: Return the column visible if no error occurred, otherwise
            raise a RuntimeError with the message.

        Example:
            For example, get visible state of row 2 in Sheet1:

            ```python
            try:
                visible = f.get_row_visible("Sheet1", 2)
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        lib.GetRowVisible.restype = types_go._BoolErrorResult
        res = lib.GetRowVisible(self.file_index, sheet.encode(ENCODE), c_int(row))
        err = res.err.decode(ENCODE)
        if not err:
            return res.val
        raise RuntimeError(err)

    def get_rows(self, sheet: str, *opts: Options) -> List[List[str]]:
        """
        Return all the rows in a sheet by given worksheet name, returned as a
        two-dimensional array, where the value of the cell is converted to the
        string type. If the cell format can be applied to the value of the cell,
        the applied value will be used, otherwise the original value will be
        used. This function fetched the rows with value or formula cells, the
        continually blank cells in the tail of each row will be skipped, so the
        length of each row may be inconsistent.

        Args:
            sheet (str): The worksheet name
            *opts (Options): Optional parameters for get rows

        Returns:
            List[List[str]]: Return all the rows in a sheet by given worksheet
            name, returned as a two-dimensional array if no error occurred,
            otherwise raise a RuntimeError with the message.

        Example:
            For example, get and traverse the value of all cells by rows on a
            worksheet named 'Sheet1':

            ```python
            rows = f.get_rows("Sheet1")
            for row in rows:
                for cell in row:
                    print(f"{cell}\t", end="")
                print()
            ```
        """
        lib.GetRows.restype = types_go._GetRowsResult
        rows = []
        options = (
            byref(py_value_to_c(opts[0], types_go._Options()))
            if opts
            else POINTER(types_go._Options)()
        )
        res = lib.GetRows(self.file_index, sheet.encode(ENCODE), options)
        err = res.err.decode(ENCODE)
        result = c_value_to_py(res, GetRowsResult()).row

        if result:
            for row in result:
                if row.cell:
                    rows.append([cell for cell in row.cell])
        if not err:
            return rows
        raise RuntimeError(err)

    def get_sheet_dimension(self, sheet: str) -> str:
        """
        Get style definition by given style index.

        Args:
            sheet (str): The worksheet name

        Returns:
            str: Return the sheet dimension if no error occurred, otherwise
            raise a RuntimeError with the message.
        """
        lib.GetSheetDimension.restype = types_go._StringErrorResult
        res = lib.GetSheetDimension(self.file_index, sheet.encode(ENCODE))
        err = res.err.decode(ENCODE)
        if not err:
            return res.val.decode(ENCODE)
        raise RuntimeError(err)

    def get_sheet_index(self, sheet: str) -> int:
        """
        Get a sheet index of the workbook by the given sheet name. If the given
        sheet name is invalid or sheet doesn't exist, it will return an integer
        type value -1.

        Args:
            sheet (str): The worksheet name

        Returns:
            int: Return the sheet index if no error occurred, otherwise raise
            a RuntimeError with the message.
        """
        lib.GetSheetIndex.restype = types_go._IntErrorResult
        res = lib.GetSheetIndex(self.file_index, sheet.encode(ENCODE))
        err = res.err.decode(ENCODE)
        if not err:
            return res.val
        raise RuntimeError(err)

    def get_sheet_list(self) -> List[str]:
        """
        Get worksheets, chart sheets, and dialog sheets name list of the
        workbook.

        Returns:
            List[str]: Return the sheet name list if no error occurred,
            otherwise return an empty list.
        """
        lib.GetSheetList.restype = types_go._StringArrayErrorResult
        res = lib.GetSheetList(self.file_index)
        arr = c_value_to_py(res, StringArrayErrorResult()).arr
        return arr if arr else []

    def get_sheet_map(self) -> Dict[int, str]:
        """
        Get worksheets, chart sheets, dialog sheets ID, and name maps of the
        workbook.

        Returns:
            Dict[int, str]: Return the sheet ID and name map if no error
            occurred, otherwise return an empty dictionary.

        Example:
            For example:

            ```python
            try:
                f = excelize.open_file("Book1.xlsx")
            except (RuntimeError, TypeError) as err:
                print(err)
                exit()
            try:
                for index, name in f.get_sheet_map().items():
                    print(index, name)
            except (RuntimeError, TypeError) as err:
                print(err)
            finally:
                err = f.close()
                if err:
                    print(err)
            ```
        """
        lib.GetSheetMap.restype = types_go._GetSheetMapResult
        sheet_map = dict()
        res = lib.GetSheetMap(self.file_index)
        result = c_value_to_py(res, GetSheetMapResult()).arr
        if result:
            for item in result:
                sheet_map[item.k] = item.v
        return sheet_map

    def get_sheet_name(self, sheet: int) -> str:
        """
        Get the sheet name of the workbook by the given sheet index.
        If the given sheet index is invalid or the sheet doesn't exist,
        it will return an empty string.

        Args:
            sheet (int): The worksheet index

        Returns:
            str: Return the sheet name if the index is valid and if no
            error occurred, otherwise raise a RuntimeError with the message.
        """
        lib.GetSheetName.restype = types_go._StringErrorResult
        res = lib.GetSheetName(self.file_index, c_int(sheet))
        err = res.err.decode(ENCODE)
        if not err:
            return res.val.decode(ENCODE)
        raise RuntimeError(err)

    def get_sheet_visible(self, sheet: str) -> bool:
        """
        Get visible state of the sheet by given sheet name.

        Args:
            sheet (str): The sheet name.

        Returns:
            bool: Return the sheet visible if no error occurred, otherwise raise
            a RuntimeError with the message.

        Example:
            For example, get the visible state of "Sheet1":

            ```python
            try:
                visible = f.get_sheet_visible("Sheet1")
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        lib.GetSheetVisible.restype = types_go._BoolErrorResult
        res = lib.GetSheetVisible(self.file_index, sheet.encode(ENCODE))
        err = res.err.decode(ENCODE)
        if not err:
            return res.val
        raise RuntimeError(err)

    def get_style(self, style_id: int) -> Optional[Style]:
        """
        Get style definition by given style ID.

        Args:
            style_id (int): The style ID

        Returns:
            Optional[Style]: Return the style object if no error occurred,
            otherwise raise a RuntimeError with the message.
        """
        lib.GetStyle.restype = types_go._GetStyleResult
        res = lib.GetStyle(self.file_index, c_int(style_id))
        err = res.err.decode(ENCODE)
        if not err:
            return c_value_to_py(res.style, Style())
        raise RuntimeError(err)

    def get_tables(self, sheet: str) -> List[Table]:
        """
        Get all tables in a worksheet by given worksheet name.

        Args:
            sheet (str): The worksheet name

        Returns:
            List[Table]: Return the table list if no error occurred, otherwise
            raise a RuntimeError with the message.
        """
        lib.GetTables.restype = types_go._GetTablesResult
        res = lib.GetTables(self.file_index, sheet.encode(ENCODE))
        tables = c_value_to_py(res, GetTablesResult()).tables
        err = res.Err.decode(ENCODE)
        if not err:
            return tables if tables else []
        raise RuntimeError(err)

    def get_workbook_props(self) -> WorkbookPropsOptions:
        """
        Get all tables in a worksheet by given worksheet name.

        Returns:
            WorkbookPropsOptions: Return the workbook property options if no
            error occurred, otherwise raise a RuntimeError with the message.
        """
        lib.GetWorkbookProps.restype = types_go._GetWorkbookPropsResult
        res = lib.GetWorkbookProps(self.file_index)
        err = res.err.decode(ENCODE)
        if not err:
            return c_value_to_py(res.opts, WorkbookPropsOptions())
        raise RuntimeError(err)

    def get_sheet_props(self, sheet_name: str) -> Optional[SheetPropsOptions]:
        """
        Get worksheet properties.

        Returns:
            Optional[SheetPropsOptions]: Return the sheet property options if no
            error occurred, otherwise raise a RuntimeError with the message.
        """
        lib.GetSheetProps.restype = types_go._GetSheetPropsResult
        res = lib.GetSheetProps(self.file_index, sheet_name.encode(ENCODE))
        err = res.err.decode(ENCODE)
        if not err:
            return c_value_to_py(res.opts, SheetPropsOptions())
        raise RuntimeError(err)

    def group_sheets(self, sheets: List[str]) -> None:
        """
        Group worksheets by given worksheets name. Group worksheets must contain
        an active worksheet.

        Args:
            sheets (List[str]): The worksheet names to be grouped.

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        lib.GroupSheets.restype = c_char_p
        array = (c_char_p * len(sheets))()
        for i, value in enumerate(sheets):
            array[i] = value.encode(ENCODE)
        err = lib.GroupSheets(self.file_index, array, c_int(len(sheets))).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def insert_cols(self, sheet: str, col: str, n: int) -> None:
        """
        Insert new columns before the given column name and number of columns.
        Use this method with caution, which will affect changes in references
        such as formulas, charts, and so on. If there is any referenced value of
        the worksheet, it will cause a file error when you open it. The excelize
        only partially updates these references currently.

        Args:
            sheet (str): The worksheet name
            col (str): The column name
            n (int): The columns

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            For example, create two columns before column C in Sheet1:

            ```python
            try:
                f.insert_cols("Sheet1", "C", 2)
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        lib.InsertCols.restype = c_char_p
        err = lib.InsertCols(
            self.file_index,
            sheet.encode(ENCODE),
            col.encode(ENCODE),
            c_int(n),
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def insert_page_break(self, sheet: str, cell: str) -> None:
        """
        Create a page break to determine where the printed page ends and where
        begins the next one by given worksheet name and cell reference, so the
        content before the page break will be printed on one page and after the
        page break on another.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        lib.InsertPageBreak.restype = c_char_p
        err = lib.InsertPageBreak(
            self.file_index,
            sheet.encode(ENCODE),
            cell.encode(ENCODE),
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def insert_rows(self, sheet: str, row: int, n: int) -> None:
        """
        Insert new rows after the given Excel row number starting from 1 and
        number of rows. Use this method with caution, which will affect changes
        in references such as formulas, charts, and so on. If there is any
        referenced value of the worksheet, it will cause a file error when you
        open it. The excelize only partially updates these references currently.

        Args:
            sheet (str): The worksheet name
            row (int): The row number
            n (int): The rows

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            For example, create two rows before row 3 in Sheet1:

            ```python
            try:
                f.insert_rows("Sheet1", 3, 2)
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        lib.InsertRows.restype = c_char_p
        err = lib.InsertRows(
            self.file_index,
            sheet.encode(ENCODE),
            c_int(row),
            c_int(n),
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def merge_cell(
        self, sheet: str, top_left_cell: str, bottom_right_cell: str
    ) -> None:
        """
        Merge cells by given range reference and sheet name. Merging cells only
        keeps the upper-left cell value, and discards the other values.

        Args:
            sheet (str): The worksheet name
            top_left_cell (str): The top-left cell reference
            bottom_right_cell (str): The right-bottom cell reference

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            For example create a merged cell of D3:E9 on Sheet1:

            ```python
            try:
                f.merge_cell("Sheet1", "D3", "E9")
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        lib.MergeCell.restype = c_char_p
        err = lib.MergeCell(
            self.file_index,
            sheet.encode(ENCODE),
            top_left_cell.encode(ENCODE),
            bottom_right_cell.encode(ENCODE),
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def move_sheet(self, source: str, target: str) -> None:
        """
        Moves a sheet to a specified position in the workbook. The function
        moves the source sheet before the target sheet. After moving, other
        sheets will be shifted to the left or right. If the sheet is already at
        the target position, the function will not perform any action. Not that
        this function will be ungroup all sheets after moving.

        Args:
            source (str): The source worksheet name
            target (str): The target worksheet name

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            For example, move Sheet2 before Sheet1:

            ```python
            try:
                f.move_sheet("Sheet2", "Sheet1")
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        lib.MoveSheet.restype = c_char_p
        err = lib.MoveSheet(
            self.file_index,
            source.encode(ENCODE),
            target.encode(ENCODE),
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def new_conditional_style(self, style: Style) -> int:
        """
        Create style for conditional format by given style format. The
        parameters are the same with the `new_style` function.

        Args:
            style (Style): The style options

        Returns:
            int: Return the style index if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        lib.NewConditionalStyle.restype = types_go._IntErrorResult
        options = py_value_to_c(style, types_go._Style())
        res = lib.NewConditionalStyle(self.file_index, byref(options))
        err = res.err.decode(ENCODE)
        if not err:
            return res.val
        raise RuntimeError(err)

    def new_sheet(self, sheet: str) -> int:
        """
        Create a new sheet by given a worksheet name and returns the index of
        the sheets in the workbook after it appended. Note that when creating a
        new workbook, the default worksheet named `Sheet1` will be created.

        Args:
            sheet (str): The worksheet name

        Returns:
            int: Return the index of the new sheet if no error occurred,
            otherwise raise a RuntimeError with the message.
        """
        lib.NewSheet.restype = types_go._IntErrorResult
        res = lib.NewSheet(self.file_index, sheet.encode(ENCODE))
        err = res.err.decode(ENCODE)
        if not err:
            return res.val
        raise RuntimeError(err)

    def new_stream_writer(self, sheet: str) -> StreamWriter:
        """
        Returns stream writer struct by given worksheet name used for writing
        data on a new existing empty worksheet with large amounts of data. Note
        that after writing data with the stream writer for the worksheet, you
        must call the 'flush' method to end the streaming writing process,
        ensure that the order of row numbers is ascending when set rows, and the
        normal mode functions and stream mode functions can not be work mixed to
        writing data on the worksheets. The stream writer will try to use
        temporary files on disk to reduce the memory usage when in-memory chunks
        data over 16MB, and you can't get cell value at this time.

        Args:
            sheet (str): The worksheet name

        Returns:
            StreamWriter: Return the stream writer object if no error occurred,
            otherwise raise a RuntimeError with the message.

        Example:
            For example, set data for worksheet of size 102400 rows x 50 columns
            with numbers:

            ```python
            import excelize, random

            f = excelize.new_file()
            try:
                sw = f.new_stream_writer("Sheet1")
                for r in range(2, 102401):
                    row = [random.randrange(640000) for _ in range(1, 51)]
                    cell = excelize.coordinates_to_cell_name(1, r, False)
                    sw.set_row(cell, row)
                sw.flush()
                f.save_as("Book1.xlsx")
            except (RuntimeError, TypeError) as err:
                print(err)
            finally:
                err = f.close()
                if err:
                    print(err)
            ```
        """
        prepare_args([sheet], [argsRule("sheet", [str])])
        lib.NewStreamWriter.restype = types_go._IntErrorResult
        res = lib.NewStreamWriter(self.file_index, sheet.encode(ENCODE))
        err = res.err.decode(ENCODE)
        if not err:
            return StreamWriter(res.val)
        raise RuntimeError(err)

    def new_style(self, style: Style) -> int:
        """
        Create the style for cells by a given style options, and returns style
        index. The same style index can not be used across different workbook.
        Note that the 'font.color' field uses an RGB color represented in
        'RRGGBB' hexadecimal notation.

        Args:
            style (Style): The style options

        Returns:
            int: Return the style index if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            For example create a borders of cell H9 on Sheet1:

            ```python
            try:
                style = f.new_style(excelize.Style(
                    border=[
                        excelize.Border(type="left", color="0000FF", style=3),
                        excelize.Border(type="top", color="00FF00", style=4),
                        excelize.Border(type="bottom", color="FFFF00", style=5),
                        excelize.Border(type="right", color="FF0000", style=6),
                        excelize.Border(type="diagonalDown", color="A020F0", style=7),
                        excelize.Border(type="diagonalUp", color="A020F0", style=8),
                    ]
                ))
                f.set_cell_style("Sheet1", "H9", "H9", style)
            except (RuntimeError, TypeError) as err:
                print(err)
            ```

            Set gradient fill with vertical variants shading styles for cell H9
            on Sheet1:

            ```python
            try:
                style = f.new_style(
                    excelize.Style(
                        fill=excelize.Fill(
                            type="gradient",
                            color=["FFFFFF", "E0EBF5"],
                            shading=1,
                        )
                    )
                )
                f.set_cell_style("Sheet1", "H9", "H9", style)
            except (RuntimeError, TypeError) as err:
                print(err)
            ```

            Set solid style pattern fill for cell H9 on Sheet1:

            ```python
            try:
                style = f.new_style(
                    excelize.Style(
                        fill=excelize.Fill(type="pattern", color=["E0EBF5"], pattern=1),
                    )
                )
                f.set_cell_style("Sheet1", "H9", "H9", style)
            except (RuntimeError, TypeError) as err:
                print(err)
            ```

            Set alignment style for cell H9 on Sheet1:

            ```python
            try:
                f.set_cell_value("Sheet1", "H9", "Style")
                style = f.new_style(
                    excelize.Style(
                        alignment=excelize.Alignment(
                            horizontal="center",
                            indent=1,
                            justify_last_line=True,
                            reading_order=0,
                            relative_indent=1,
                            shrink_to_fit=True,
                            text_rotation=45,
                            vertical="",
                            wrap_text=True,
                        ),
                    )
                )
                f.set_cell_style("Sheet1", "H9", "H9s", style)
            except (RuntimeError, TypeError) as err:
                print(err)
            ```

            Dates and times in Excel are represented by real numbers, for
            example "Apr 7 2017 12:00 PM" is represented by the number 42920.5.
            Set date and time format for cell H9 on Sheet1:

            ```python
            try:
                f.set_cell_value("Sheet1", "H9", 42920.5)
                f.set_col_width("Sheet1", "H", "H", 13)
                style = f.new_style(excelize.Style(num_fmt=22))
                f.set_cell_style("Sheet1", "H9", "H9", style)
            except (RuntimeError, TypeError) as err:
                print(err)
            ```

            Set font style for cell H9 on Sheet1:

            ```python
            try:
                f.set_cell_value("Sheet1", "H9", "Excel")
                style = f.new_style(
                    excelize.Style(
                        font=excelize.Font(
                            bold=True,
                            italic=True,
                            family="Times New Roman",
                            size=36,
                            color="777777",
                        )
                    )
                )
                f.set_cell_style("Sheet1", "H9", "H9", style)
            except (RuntimeError, TypeError) as err:
                print(err)
            ```

            Hide and lock for cell H9 on Sheet1:

            ```python
            try:
                style = f.new_style(
                    excelize.Style(
                        protection=excelize.Protection(hidden=True, locked=True),
                    )
                )
                f.set_cell_style("Sheet1", "H9", "H9", style)
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        lib.NewStyle.restype = types_go._IntErrorResult
        options = py_value_to_c(style, types_go._Style())
        res = lib.NewStyle(self.file_index, byref(options))
        err = res.err.decode(ENCODE)
        if not err:
            return res.val
        raise RuntimeError(err)

    def protect_sheet(self, sheet: str, opts: SheetProtectionOptions) -> None:
        """
        Prevent other users from accidentally or deliberately changing, moving,
        or deleting data in a worksheet. The optional field AlgorithmName
        specified hash algorithm, support XOR, MD4, MD5, SHA-1, SHA2-56,
        SHA-384, and SHA-512 currently, if no hash algorithm specified, will be
        using the XOR algorithm as default.

        Args:
            sheet (str): The worksheet name
            opts (SheetProtectionOptions): The sheet protection options

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            For example, protect Sheet1 with protection settings:

            ```python
            try:
                f.protect_sheet("Sheet1", excelize.SheetProtectionOptions(
                    algorithm_name="SHA-512",
                    password="password",
                    select_locked_cells=True,
                    select_unlocked_cells=True,
                    edit_scenarios=True,
                ))
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        lib.ProtectSheet.restype = c_char_p
        options = py_value_to_c(opts, types_go._SheetProtectionOptions())
        err = lib.ProtectSheet(
            self.file_index, sheet.encode(ENCODE), byref(options)
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def protect_workbook(self, opts: WorkbookProtectionOptions) -> None:
        """
        Prevent other users from viewing hidden worksheets, adding, moving,
        deleting, or hiding worksheets, and renaming worksheets in a workbook.
        The optional field algorithm_name specified hash algorithm, support XOR,
        MD4, MD5, SHA-1, SHA2-56, SHA-384, and SHA-512 currently, if no hash
        algorithm specified, will be using the XOR algorithm as default. The
        generated workbook only works on Microsoft Office 2007 and later.

        Args:
            opts (WorkbookProtectionOptions): The workbook protection options

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            For example, protect workbook with protection settings:

            ```python
            try:
                f.protect_workbook(excelize.WorkbookProtectionOptions(
                    password="password",
                    lock_structure=True,
                ))
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        lib.ProtectWorkbook.restype = c_char_p
        options = py_value_to_c(opts, types_go._WorkbookProtectionOptions())
        err = lib.ProtectWorkbook(self.file_index, byref(options)).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def remove_col(self, sheet: str, col: str) -> None:
        """
        Remove single column by given worksheet name and column index.
        Use this method with caution, which will affect changes in references
        such as formulas, charts, and so on. If there is any referenced value of
        the worksheet, it will cause a file error when you open it. The excelize
        only partially updates these references currently.

        Args:
            sheet (str): The worksheet name
            col (str): The column name

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            For example, remove column C in Sheet1:

            ```python
            try:
                f.remove_col("Sheet1", "C")
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        lib.RemoveCol.restype = c_char_p
        err = lib.RemoveCol(
            self.file_index, sheet.encode(ENCODE), col.encode(ENCODE)
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def remove_page_break(self, sheet: str, cell: str) -> None:
        """
        Remove a page break by given worksheet name and cell reference.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        lib.RemovePageBreak.restype = c_char_p
        err = lib.RemovePageBreak(
            self.file_index, sheet.encode(ENCODE), cell.encode(ENCODE)
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def remove_row(self, sheet: str, row: int) -> None:
        """
        Remove single row by given worksheet name and Excel row number. Use this
        method with caution, which will affect changes in references such as
        formulas, charts, and so on. If there is any referenced value of the
        worksheet, it will cause a file error when you open it. The excelize
        only partially updates these references currently.

        Args:
            sheet (str): The worksheet name
            row (int): The row number

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            For example, remove row 3 in Sheet1:

            ```python
            try:
                f.remove_row("Sheet1", 3)
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        lib.RemoveRow.restype = c_char_p
        err = lib.RemoveRow(self.file_index, sheet.encode(ENCODE), c_int(row)).decode(
            ENCODE
        )
        if err != "":
            raise RuntimeError(err)

    def search_sheet(self, sheet: str, value: str, *reg: bool) -> List[str]:
        """
        Get cell reference by given worksheet name, cell value, and regular
        expression. The function doesn't support searching on the calculated
        result, formatted numbers and conditional lookup currently. If it is a
        merged cell, it will return the cell reference of the upper left cell of
        the merged range reference.

        Args:
            sheet (str): The worksheet name
            value (str): The cell value to search
            *reg (bool): Specifies if search with regular expression

        Returns:
            List[str]: Return the cell name list if no error occurred,
            otherwise raise a RuntimeError with the message.

        Example:
            An example of search the cell reference of the value of "100" on
            Sheet1:

            ```python
            try:
                result = f.search_sheet("Sheet1", "100")
            except (RuntimeError, TypeError) as err:
                print(err)
            ```

            An example of search the cell reference where the numerical value in
            the range of "0-9" of Sheet1 is described:

            ```python
            try:
                result = f.search_sheet("Sheet1", "[0-9]", True)
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        lib.SearchSheet.restype = types_go._StringArrayErrorResult
        res = lib.SearchSheet(
            self.file_index,
            sheet.encode(ENCODE),
            value.encode(ENCODE),
            reg[0] if reg else False,
        )
        arr = c_value_to_py(res, StringArrayErrorResult()).arr
        err = res.Err.decode(ENCODE)
        if not err:
            return arr if arr else []
        raise RuntimeError(err)

    def set_active_sheet(self, index: int) -> None:
        """
        Set the default active sheet of the workbook by a given index. Note that
        the active index is different from the ID returned by function
        `get_sheet_map`. It should be greater than or equal to 0 and less than
        the total worksheet numbers.

        Args:
            index (int): The sheet index

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        err, lib.SetActiveSheet.restype = None, c_char_p
        err = lib.SetActiveSheet(self.file_index, index).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def set_cell_bool(self, sheet: str, cell: str, value: bool) -> None:
        """
        Set bool type value of a cell by given worksheet name, cell reference
        and cell value.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference
            value (bool): The cell value

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        err, lib.SetCellBool.restype = None, c_char_p
        err = lib.SetCellBool(
            self.file_index, sheet.encode(ENCODE), cell.encode(ENCODE), value
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def set_cell_formula(
        self, sheet: str, cell: str, formula: str, *opts: FormulaOpts
    ) -> None:
        """
        Set formula on the cell is taken according to the given worksheet name
        and cell formula settings. The result of the formula cell can be
        calculated when the worksheet is opened by the Office Excel application
        or can be using the `calc_cell_value` function also can get the
        calculated cell value. If the Excel application doesn't calculate the
        formula automatically when the workbook has been opened, please call
        `update_linked_value` after setting the cell formula functions.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference
            formula (str): The cell formula
            *opts (FormulaOpts): The formula options

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            Example 1, set normal formula "SUM(A1,B1)" for the cell "A3" on
            "Sheet1":

            ```python
            f.set_cell_formula("Sheet1", "A3", "SUM(A1,B1)")
            ```

            Example 2, set one-dimensional vertical constant array (column
            array) formula "1,2,3" for the cell "A3" on "Sheet1":

            ```python
            f.set_cell_formula("Sheet1", "A3", "{1;2;3}")
            ```

            Example 3, set one-dimensional horizontal constant array (row array)
            formula '"a","b","c"' for the cell "A3" on "Sheet1":

            ```python
            f.set_cell_formula("Sheet1", "A3", "{\"a\",\"b\",\"c\"}")
            ```

            Example 4, set two-dimensional constant array formula
            '{1,2,"a","b"}' for the cell "A3" on "Sheet1":

            ```python
            f.set_cell_formula(
                "Sheet1",
                "A3",
                '{1,2;"a","b"}',
                excelize.FormulaOpts(ref="A3:A3", type="array"),
            )
            ```

            Example 5, set range array formula "A1:A2" for the cell "A3" on
            "Sheet1":

            ```python
            f.set_cell_formula(
                "Sheet1",
                "A3",
                "A1:A2",
                excelize.FormulaOpts(ref="A3:A3", type="array"),
            )
            ```

            Example 6, set shared formula "A1+B1" for the cell "C1:C5" on
            "Sheet1", "C1" is the master cell:

            ```python
            f.set_cell_formula(
                "Sheet1",
                "C1",
                "A1+B1",
                excelize.FormulaOpts(ref="C1:C5", type="shared"),
            )
            ```

            Example 7, set table formula "SUM(Table1[[A]:[B]])" for the cell
            "C2" on "Sheet1":

            ```python
            import excelize

            f = excelize.new_file()
            try:
                for idx, row in enumerate([["A", "B", "C"], [1, 2]]):
                    f.set_sheet_row("Sheet1", f"A{idx+1}", row)
                f.add_table("Sheet1", excelize.Table(
                    range="A1:C2",
                    name="Table1",
                    style_name="TableStyleMedium2"
                ))
                f.set_cell_formula(
                    "Sheet1",
                    "C2",
                    "SUM(Table1[[A]:[B]])",
                    excelize.FormulaOpts(type="dataTable")
                )
                f.save_as("Book1.xlsx")
            except (RuntimeError, TypeError) as err:
                print(err)
            finally:
                err = f.close()
                if err:
                    print(err)
            ```
        """
        err, lib.SetCellFormula.restype = None, c_char_p
        options = (
            byref(py_value_to_c(opts[0], types_go._FormulaOpts()))
            if opts
            else POINTER(types_go._FormulaOpts)()
        )
        err = lib.SetCellFormula(
            self.file_index,
            sheet.encode(ENCODE),
            cell.encode(ENCODE),
            formula.encode(ENCODE),
            options,
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def set_cell_hyperlink(
        self,
        sheet: str,
        cell: str,
        link: str,
        link_type: str,
        *opts: HyperlinkOpts,
    ) -> None:
        """
        Set cell hyperlink by given worksheet name and link URL address. The
        `link_type` defines three types of hyperlink "External" for website or
        "Location" for moving to one of cell in this workbook or "None" for
        remove hyperlink. Maximum limit hyperlinks in a worksheet is 65530.
        This function is only used to set the hyperlink of the cell and doesn't
        affect the value of the cell. If you need to set the value of the cell
        please use the other functions such as `set_cell_style` or
        `set_sheet_row`.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference
            link (str): The hyperlink
            link_type (str): The hyperlink type
            *opts (HyperlinkOpts): The hyperlink options

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            The below is example for external link.

            ```python
            display = "https://github.com/xuri/excelize"
            try:
                f.set_cell_hyperlink(
                    "Sheet1",
                    "A3",
                    display,
                    "External",
                    excelize.HyperlinkOpts(display=display, tooltip="Excelize on GitHub"),
                )
                # Set underline and font color style for the cell.
                style = f.new_style(
                    excelize.Style(
                        font=excelize.Font(color="1265BE", underline="single")
                    )
                )
                f.set_cell_style("Sheet1", "A3", "A3", style)
            except (RuntimeError, TypeError) as err:
                print(err)
            ```

            This is another example for "Location":

            ```python
            f.set_cell_hyperlink("Sheet1", "A3", "Sheet1!A40", "Location")
            ```
        """
        err, lib.SetCellHyperLink.restype = None, c_char_p
        options = (
            byref(py_value_to_c(opts[0], types_go._HyperlinkOpts()))
            if opts
            else POINTER(types_go._HyperlinkOpts)()
        )
        err = lib.SetCellHyperLink(
            self.file_index,
            sheet.encode(ENCODE),
            cell.encode(ENCODE),
            link.encode(ENCODE),
            link_type.encode(ENCODE),
            options,
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def set_cell_int(self, sheet: str, cell: str, value: int) -> None:
        """
        Set int type value of a cell by given worksheet name, cell reference and
        cell value.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference
            value (int): The cell value

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        lib.SetCellInt.restype = c_char_p
        err = lib.SetCellInt(
            self.file_index,
            sheet.encode(ENCODE),
            cell.encode(ENCODE),
            value,
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def set_cell_rich_text(
        self,
        sheet: str,
        cell: str,
        runs: List[RichTextRun],
    ) -> None:
        """
        Set cell with rich text by given worksheet name, cell reference and rich
        text runs.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference
            runs (List[RichTextRun]): The rich text runs

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            For example, set rich text on the A1 cell of the worksheet named
            Sheet1:

            ```python
            f = excelize.new_file()
            try:
                f.set_row_height("Sheet1", 1, 35)
                f.set_col_width("Sheet1", "A", "A", 44)
                f.set_cell_rich_text(
                    "Sheet1",
                    "A1",
                    [
                        excelize.RichTextRun(
                            text="bold",
                            font=excelize.Font(
                                bold=True,
                                color="2354E8",
                                family="Times New Roman",
                            ),
                        ),
                        excelize.RichTextRun(
                            text=" and ",
                            font=excelize.Font(
                                family="Times New Roman",
                            ),
                        ),
                        excelize.RichTextRun(
                            text="italic ",
                            font=excelize.Font(
                                bold=True,
                                color="E83723",
                                italic=True,
                                family="Times New Roman",
                            ),
                        ),
                        excelize.RichTextRun(
                            text="text with color and font-family,",
                            font=excelize.Font(
                                bold=True,
                                color="2354E8",
                                family="Times New Roman",
                            ),
                        ),
                        excelize.RichTextRun(
                            text="\r\nlarge text with ",
                            font=excelize.Font(
                                size=14,
                                color="AD23E8",
                            ),
                        ),
                        excelize.RichTextRun(
                            text="strike",
                            font=excelize.Font(
                                color="E89923",
                                strike=True,
                            ),
                        ),
                        excelize.RichTextRun(
                            text=" superscript",
                            font=excelize.Font(
                                color="DBC21F",
                                vert_align="superscript",
                            ),
                        ),
                        excelize.RichTextRun(
                            text=" and ",
                            font=excelize.Font(
                                size=14,
                                color="AD23E8",
                                vert_align="baseline",
                            ),
                        ),
                        excelize.RichTextRun(
                            text="underline",
                            font=excelize.Font(
                                color="23E833",
                                vert_align="single",
                            ),
                        ),
                        excelize.RichTextRun(
                            text=" subscript.",
                            font=excelize.Font(
                                color="017505",
                                vert_align="subscript",
                            ),
                        ),
                    ],
                )
                style = f.new_style(
                    excelize.Style(
                        alignment=excelize.Alignment(wrap_text=True),
                    )
                )
                f.set_cell_style("Sheet1", "A1", "A1", style)
                f.save_as("Book1.xlsx")
            except (RuntimeError, TypeError) as err:
                print(err)
            finally:
                err = f.close()
                if err:
                    print(err)
            ```
        """
        lib.SetCellRichText.restype = c_char_p
        vals = (types_go._RichTextRun * len(runs))()
        for i, value in enumerate(runs):
            vals[i] = py_value_to_c(value, types_go._RichTextRun())
        err = lib.SetCellRichText(
            self.file_index,
            sheet.encode(ENCODE),
            cell.encode(ENCODE),
            byref(vals),
            len(vals),
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def set_cell_str(self, sheet: str, cell: str, value: str) -> None:
        """
        Set string type value of a cell. Total number of characters that a cell
        can contain 32767 characters.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference
            value (str): The cell value

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        lib.SetCellStr.restype = c_char_p
        err = lib.SetCellStr(
            self.file_index,
            sheet.encode(ENCODE),
            cell.encode(ENCODE),
            value.encode(ENCODE),
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def set_cell_style(
        self,
        sheet: str,
        top_left_cell: str,
        bottom_right_cell: str,
        style_id: int,
    ) -> None:
        """
        Add style attribute for cells by given worksheet name, range reference
        and style ID. Style indexes can be obtained with the new_style function.
        Note that diagonalDown and diagonalUp type border should be use same
        color in the same range. This function will overwrite the existing
        styles for the cell, it won't append or merge style with existing
        styles.

        Args:
            sheet (str): The worksheet name
            top_left_cell (str): The top-left cell reference
            bottom_right_cell (str): The right-bottom cell reference
            style_id (int): The style ID

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        lib.SetCellStyle.restype = c_char_p
        err = lib.SetCellStyle(
            self.file_index,
            sheet.encode(ENCODE),
            top_left_cell.encode(ENCODE),
            bottom_right_cell.encode(ENCODE),
            style_id,
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def set_cell_value(
        self,
        sheet: str,
        cell: str,
        value: Union[bool, float, int, str, date, datetime, None],
    ) -> None:
        """
        Set the value of a cell. The specified coordinates should not be in the
        first row of the table, a complex number can be set with string text.

        Note that default date format is m/d/yy h:mm of datetime type value. You
        can set numbers format by the `set_cell_style` function. If you need to
        set the specialized date in Excel like January 0, 1900 or February 29,
        1900, these times can not representation in Python language datetime
        data type. Please set the cell value as number 0 or 60, then create and
        bind the date-time number format style for the cell.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference
            value (Union[bool, float, int, str, date, datetime, None]): The cell
            value to be write

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        prepare_args(
            [sheet, cell, value],
            [
                argsRule("sheet", [str]),
                argsRule("cell", [str]),
                argsRule(
                    "value",
                    [bool, float, int, str, date, datetime, type(None)],
                ),
            ],
        )
        lib.SetCellValue.restype = c_char_p
        err = lib.SetCellValue(
            self.file_index,
            sheet.encode(ENCODE),
            cell.encode(ENCODE),
            byref(py_value_to_c_interface(value)),
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def set_col_outline_level(self, sheet: str, col: str, level: int) -> None:
        """
        Set outline level of a single column by given worksheet name and column
        name.

        Args:
            sheet (str): The worksheet name
            col (str): The column name
            level (int): The out level, acceptable value from 1 to 7

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            For example, set outline level of column D in Sheet1 to 2:

            ```python
            try:
                f.set_col_outline_level("Sheet1", "D", 2)
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        lib.SetColOutlineLevel.restype = c_char_p
        err = lib.SetColOutlineLevel(
            self.file_index, sheet.encode(ENCODE), col.encode(ENCODE), level
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def set_col_style(self, sheet: str, columns: str, style_id: int) -> None:
        """
        Set style of columns by given worksheet name, columns range and style
        ID. Note that this will overwrite the existing styles for the columns,
        it won't append or merge style with existing styles.

        Args:
            sheet (str): The worksheet name
            columns (str): The columns range
            style_id (int): The style ID

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            For example set style of column H on Sheet1:

            ```python
            try:
                f.set_col_style("Sheet1", "H", style)
            except (RuntimeError, TypeError) as err:
                print(err)
            ```

            Set style of columns C:F on Sheet1:

            ```python
            try:
                f.set_col_style("Sheet1", "C:F", style)
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        lib.SetColStyle.restype = c_char_p
        err = lib.SetColStyle(
            self.file_index, sheet.encode(ENCODE), columns.encode(ENCODE), style_id
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def set_col_visible(self, sheet: str, columns: str, visible: bool) -> None:
        """
        Set visible columns by given worksheet name, columns range and
        visibility.

        Args:
            sheet (str): The worksheet name
            columns (str): The columns range
            visible (bool): The column visible

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            For example hide column D on Sheet1:

            ```python
            try:
                f.set_col_visible("Sheet1", "D", False)
            except (RuntimeError, TypeError) as err:
                print(err)
            ```

            Hide the columns from `D` to `F` (included):

            ```python
            try:
                f.set_col_visible("Sheet1", "D:F", False)
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        lib.SetColVisible.restype = c_char_p
        err = lib.SetColVisible(
            self.file_index, sheet.encode(ENCODE), columns.encode(ENCODE), visible
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def set_col_width(
        self, sheet: str, start_col: str, end_col: str, width: float
    ) -> None:
        """
        Set the width of a single column or multiple columns.

        Args:
            sheet (str): The worksheet name
            start_col (str): The start column name
            end_col (str): The end column name
            width (float): The column width

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            For example set column width for column A to H on Sheet1:

            ```python
            try:
                f.set_col_width("Sheet1", "A", "H", 20)
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        lib.SetColWidth.restype = c_char_p
        err = lib.SetColWidth(
            self.file_index,
            sheet.encode(ENCODE),
            start_col.encode(ENCODE),
            end_col.encode(ENCODE),
            c_double(width),
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def set_conditional_format(
        self,
        sheet: str,
        range_ref: str,
        opts: List[ConditionalFormatOptions],
    ) -> None:
        """
        Create conditional formatting rule for cell value. Conditional
        formatting is a feature of Excel which allows you to apply a format to a
        cell or a range of cells based on certain criteria.

        Args:
            sheet (str): The worksheet name
            range_ref (str): The top-left and right-bottom cell range reference
            opts (List[ConditionalFormatOptions]): The conditional format options

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        lib.SetConditionalFormat.restype = c_char_p
        vals = (types_go._ConditionalFormatOptions * len(opts))()
        for i, value in enumerate(opts):
            vals[i] = py_value_to_c(value, types_go._ConditionalFormatOptions())
        err = lib.SetConditionalFormat(
            self.file_index,
            sheet.encode(ENCODE),
            range_ref.encode(ENCODE),
            byref(vals),
            len(vals),
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def set_default_font(self, font_name: str) -> None:
        """
        Set the default font name in the workbook. The spreadsheet generated by
        excelize default font is Calibri.

        Args:
            font_name (str): The font name

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        lib.SetDefaultFont.restype = c_char_p
        err = lib.SetDefaultFont(self.file_index, font_name.encode(ENCODE)).decode(
            ENCODE
        )
        if err != "":
            raise RuntimeError(err)

    def set_defined_name(self, defined_name: DefinedName) -> None:
        """
        Set the defined names of the workbook or worksheet. If not specified
        scope, the default scope is workbook.

        Args:
            defined_name (DefinedName): The defined name options

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            For example:

            ```python
            f.set_defined_name(excelize.DefinedName(
                name="Amount",
                refers_to="Sheet1!$A$2:$D$5",
                comment="defined name comment",
                scope="Sheet2",
            ))
            ```

            If you fill the `refers_to` property with only one columns range
            without a comma, it will work as "Columns to repeat at left" only.
            For example:

            ```python
            f.set_defined_name(excelize.DefinedName(
                name="_xlnm.Print_Titles",
                refers_to="Sheet1!$A:$A",
                scope="Sheet1"
            ))
            ```

            If you fill the `refers_to` property with only one rows range
            without a comma, it will work as "Rows to repeat at top" only.
            For example:

            ```python
            f.set_defined_name(excelize.DefinedName(
                name="_xlnm.Print_Titles",
                refers_to="Sheet1!$1:$1",
                scope="Sheet1"
            ))
            ```
        """
        lib.SetDefinedName.restype = c_char_p
        options = py_value_to_c(defined_name, types_go._DefinedName())
        err = lib.SetDefinedName(self.file_index, byref(options)).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def set_doc_props(self, doc_properties: DocProperties) -> None:
        """
        Set document core properties.

        Args:
            doc_properties (DocProperties): The doc properties

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            For example:

            ```python
            try:
                f.set_doc_props(
                    excelize.DocProperties(
                        category="category",
                        content_status="Draft",
                        created="2019-06-04T22:00:10Z",
                        creator="Excelize for Python",
                        description="This file created by Excelize for Python",
                        identifier="xlsx",
                        keywords="Spreadsheet",
                        last_modified_by="Author Name",
                        modified="2019-06-04T22:00:10Z",
                        revision="0",
                        subject="Test Subject",
                        title="Test Title",
                        language="en-US",
                        version="1.0.0",
                    )
                )
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        lib.SetDocProps.restype = c_char_p
        options = py_value_to_c(doc_properties, types_go._DocProperties())
        err = lib.SetDocProps(self.file_index, byref(options)).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def set_header_footer(self, sheet: str, opts: HeaderFooterOptions) -> None:
        """
        Set headers and footers by given worksheet name and the control
        characters.

        Args:
            sheet (str): The worksheet name
            opts (HeaderFooterOptions): The header footer options

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            For example:

            ```python
            try:
                f.set_header_footer(
                    "Sheet1",
                    excelize.HeaderFooterOptions(
                        different_first=True,
                        different_odd_even=True,
                        odd_header="&R&P",
                        odd_footer="&C&F",
                        even_header="&L&P",
                        even_footer="&L&D&R&T",
                        first_header="&CCenter &\"-,Bold\"Bold&\"-,Regular\"HeaderU+000A&D",
                    ),
                )
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        lib.SetHeaderFooter.restype = c_char_p
        options = py_value_to_c(opts, types_go._HeaderFooterOptions())
        err = lib.SetHeaderFooter(
            self.file_index, sheet.encode(ENCODE), byref(options)
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def set_page_layout(self, sheet: str, opts: PageLayoutOptions) -> None:
        """
        Sets worksheet page layout.

        Args:
            sheet (str): The worksheet name
            opts (PageLayoutOptions): The page layout options

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        lib.SetPageLayout.restype = c_char_p
        options = py_value_to_c(opts, types_go._PageLayoutOptions())
        err = lib.SetPageLayout(
            self.file_index, sheet.encode(ENCODE), byref(options)
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def set_page_margins(self, sheet: str, opts: PageLayoutMarginsOptions) -> None:
        """
        Set worksheet page margins.

        Args:
            sheet (str): The worksheet name
            opts (PageLayoutMarginsOptions): The page margins options

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        lib.SetPageMargins.restype = c_char_p
        options = py_value_to_c(opts, types_go._PageLayoutMarginsOptions())
        err = lib.SetPageMargins(
            self.file_index, sheet.encode(ENCODE), byref(options)
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def set_panes(self, sheet: str, opts: Panes) -> None:
        """
        Create and remove freeze panes and split panes by given worksheet name
        and panes options.

        Args:
            sheet (str): The worksheet name
            opts (Panes): The panes options

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        lib.SetPanes.restype = c_char_p
        options = py_value_to_c(opts, types_go._Panes())
        err = lib.SetPanes(
            self.file_index, sheet.encode(ENCODE), byref(options)
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def set_row_height(self, sheet: str, row: int, height: float) -> None:
        """
        Set the height of a single row. If the value of height is 0, will hide
        the specified row, if the value of height is -1, will unset the custom
        row height.

        Args:
            sheet (str): The worksheet name
            row (int): The row number
            height (float): The row height

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            For example, set the height of the first row in Sheet1:

            ```python
            try:
                f.set_row_height("Sheet1", 1, 50)
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        lib.SetRowHeight.restype = c_char_p
        err = lib.SetRowHeight(
            self.file_index, sheet.encode(ENCODE), c_int(row), c_double(height)
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def set_row_outline_level(self, sheet: str, row: int, level: int) -> None:
        """
        Set outline level number of a single row by given worksheet name and
        row number. The range of `level` parameter value from 1 to 7.

        Args:
            sheet (str): The worksheet name
            row (int): The row number
            level (int): The outline level

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            For example, outline row 2 in Sheet1 to level 1:

            ```python
            try:
                f.set_row_outline_level("Sheet1", 2, 1)
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        lib.SetRowOutlineLevel.restype = c_char_p
        err = lib.SetRowOutlineLevel(
            self.file_index, sheet.encode(ENCODE), c_int(row), c_int(level)
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def set_row_style(self, sheet: str, start: int, end: int, style_id: int) -> None:
        """
        Set the style of rows by given worksheet name, row range, and style ID.
        Note that this will overwrite the existing styles for the rows, it won't
        append or merge style with existing styles.

        Args:
            sheet (str): The worksheet name
            start (int): The start row number
            end (int): The end row number
            style_id (int): The style ID

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            For example set style of row 1 on Sheet1:

            ```python
            try:
                f.set_row_style("Sheet1", 1, 1, style_id)
            except (RuntimeError, TypeError) as err:
                print(err)
            ```

            Set style of rows 1 to 10 on Sheet1:

            ```python
            try:
                f.set_row_style("Sheet1", 1, 10, style_id)
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        lib.SetRowStyle.restype = c_char_p
        err = lib.SetRowStyle(
            self.file_index,
            sheet.encode(ENCODE),
            c_int(start),
            c_int(end),
            c_int(style_id),
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def set_row_visible(self, sheet: str, row: int, visible: bool) -> None:
        """
        Set visible of a single row by given worksheet name and Excel row
        number.

        Args:
            sheet (str): The worksheet name
            row (int): The row number
            visible (bool): The row's visibility

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            For example, hide row 2 in Sheet1:

            ```python
            try:
                f.set_row_visible("Sheet1", 2, False)
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        lib.SetRowVisible.restype = c_char_p
        err = lib.SetRowVisible(
            self.file_index,
            sheet.encode(ENCODE),
            c_int(row),
            c_bool(visible),
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def set_sheet_background(self, sheet: str, picture: str) -> None:
        """
        Set background picture by given worksheet name and file path. Supported
        image types: BMP, EMF, EMZ, GIF, JPEG, JPG, PNG, SVG, TIF, TIFF, WMF,
        and WMZ.

        Args:
            sheet (str): The worksheet name
            picture (str): The image file path

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        lib.SetSheetBackground.restype = c_char_p
        err = lib.SetSheetBackground(
            self.file_index,
            sheet.encode(ENCODE),
            picture.encode(ENCODE),
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def set_sheet_background_from_bytes(
        self, sheet: str, extension: str, picture: bytes
    ) -> None:
        """
        Set background picture by given worksheet name, extension name and image
        data. Supported image types: BMP, EMF, EMZ, GIF, JPEG, JPG, PNG, SVG,
        TIF, TIFF, WMF, and WMZ.

        Args:
            sheet (str): The worksheet name
            extension (str): The image extension
            picture (bytes): The contents buffer of the file

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        lib.SetSheetBackgroundFromBytes.restype = c_char_p
        err = lib.SetSheetBackgroundFromBytes(
            self.file_index,
            sheet.encode(ENCODE),
            extension.encode(ENCODE),
            cast(picture, POINTER(c_ubyte)),
            len(picture),
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def set_sheet_col(
        self,
        sheet: str,
        cell: str,
        values: List[Union[None, int, str, bool, datetime, date]],
    ) -> None:
        """
        Writes cells to column by given worksheet name, starting cell reference
        and cell values list.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference
            values (List[Union[None, int, str, bool, datetime, date]]): The cell
            values

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            For example, writes an array to column `B` start with the cell `B6`
            on `Sheet1`:

            ```python
            try:
                f.set_sheet_col("Sheet1", "B6", ["1", None, 2])
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        lib.SetSheetCol.restype = c_char_p
        vals = (types_go._Interface * len(values))()
        for i, value in enumerate(values):
            vals[i] = py_value_to_c_interface(value)
        err = lib.SetSheetCol(
            self.file_index,
            sheet.encode(ENCODE),
            cell.encode(ENCODE),
            byref(vals),
            len(vals),
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def set_sheet_dimension(self, sheet: str, range_ref: str) -> None:
        """
        Set or remove the used range of the worksheet by a given range
        reference. It specifies the row and column bounds of used cells in the
        worksheet. The range reference is set using the A1 reference style
        (e.g., "A1:D5"). Passing an empty range reference will remove the used
        range of the worksheet.

        Args:
            sheet (str): The worksheet name
            range_ref (str): The top-left and right-bottom cell range reference

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        lib.SetSheetDimension.restype = c_char_p
        err = lib.SetSheetDimension(
            self.file_index,
            sheet.encode(ENCODE),
            range_ref.encode(ENCODE),
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def set_sheet_name(self, source: str, target: str) -> None:
        """
        Set the worksheet name by given source and target worksheet names.
        Maximum 31 characters are allowed in sheet title and this function only
        changes the name of the sheet and will not update the sheet name in the
        formula or reference associated with the cell. So there may be problem
        formula error or reference missing.

        Args:
            source (str): The source sheet name
            target (str): The target sheet name

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        lib.SetSheetName.restype = c_char_p
        err = lib.SetSheetName(
            self.file_index,
            source.encode(ENCODE),
            target.encode(ENCODE),
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def set_sheet_props(self, sheet: str, opts: SheetPropsOptions) -> None:
        """
        Set worksheet properties.

        Args:
            sheet (str): The worksheet name
            opts (SheetPropsOptions): The sheet properties options

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        lib.SetSheetProps.restype = c_char_p
        options = py_value_to_c(opts, types_go._SheetPropsOptions())
        err = lib.SetSheetProps(
            self.file_index, sheet.encode(ENCODE), byref(options)
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def set_sheet_row(
        self,
        sheet: str,
        cell: str,
        values: List[Union[None, int, str, bool, datetime, date]],
    ) -> None:
        """
        Writes cells to row by given worksheet name, starting cell reference and
        cell values list.

        Args:
            sheet (str): The worksheet name
            cell (str): The cell reference
            values (List[Union[None, int, str, bool, datetime, date]]): The cell
            values

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            For example, writes an array to row `6` start with the cell `B6` on
            `Sheet1`:

            ```python
            try:
                f.set_sheet_row("Sheet1", "B6", ["1", None, 2])
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        lib.SetSheetRow.restype = c_char_p
        vals = (types_go._Interface * len(values))()
        for i, value in enumerate(values):
            vals[i] = py_value_to_c_interface(value)
        err = lib.SetSheetRow(
            self.file_index,
            sheet.encode(ENCODE),
            cell.encode(ENCODE),
            byref(vals),
            len(vals),
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def set_sheet_view(self, sheet: str, view_index: int, opts: ViewOptions) -> None:
        """
        Sets sheet view options. The viewIndex may be negative and if so is
        counted backward (-1 is the last view).

        Args:
            sheet (str): The worksheet name
            view_index (int): The sheet view index
            opts (ViewOptions): The sheet view options

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        lib.SetSheetView.restype = c_char_p
        options = py_value_to_c(opts, types_go._ViewOptions())
        err = lib.SetSheetView(
            self.file_index, sheet.encode(ENCODE), view_index, byref(options)
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def set_sheet_visible(self, sheet: str, visible: bool, *very_hidden: bool) -> None:
        """
        Set worksheet visible by given worksheet name. A workbook must contain
        at least one visible worksheet. If the given worksheet has been
        activated, this setting will be invalidated. The third optional
        very_hidden parameter only works when visible was False.

        Args:
            sheet (str): The worksheet name
            visible (bool): The worksheet visibility
            *very_hidden (bool): Optional boolean very hidden parameter

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            For example, hide `Sheet1`:

            ```python
            f.set_sheet_visible("Sheet1", False)
            ```
        """
        lib.SetSheetVisible.restype = c_char_p
        vh = False
        if len(very_hidden) > 0:
            vh = very_hidden[0]
        err = lib.SetSheetVisible(
            self.file_index, sheet.encode(ENCODE), visible, vh
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def set_workbook_props(self, opts: WorkbookPropsOptions) -> None:
        """
        Sets workbook properties.

        Args:
            opts (WorkbookPropsOptions): The workbook property options

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        lib.SetWorkbookProps.restype = c_char_p
        options = py_value_to_c(opts, types_go._WorkbookPropsOptions())
        err = lib.SetWorkbookProps(self.file_index, byref(options)).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def ungroup_sheets(self) -> None:
        """
        Ungroup worksheets.

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        lib.UngroupSheets.restype = c_char_p
        err = lib.UngroupSheets(self.file_index).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def unmerge_cell(
        self, sheet: str, top_left_cell: str, bottom_right_cell: str
    ) -> None:
        """
        Unmerge a given range reference.

        Args:
            sheet (str): The worksheet name
            top_left_cell (str): The top-left cell reference
            bottom_right_cell (str): The right-bottom cell reference

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.

        Example:
            Unmerge range reference D3:E9 on Sheet1:

            ```python
            try:
                f.unmerge_cell("Sheet1", "D3", "E9")
            except (RuntimeError, TypeError) as err:
                print(err)
            ```
        """
        lib.UnmergeCell.restype = c_char_p
        err = lib.UnmergeCell(
            self.file_index,
            sheet.encode(ENCODE),
            top_left_cell.encode(ENCODE),
            bottom_right_cell.encode(ENCODE),
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def unprotect_sheet(self, sheet: str, *password: str) -> None:
        """
        Remove protection for a sheet, specified the second optional password
        parameter to remove sheet protection with password verification.

        Args:
            sheet (str): The worksheet name
            *password (str): Optional password for sheet protection verification

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        lib.UnprotectSheet.restype = c_char_p
        passwd = password[0] if len(password) > 0 else ""
        err = lib.UnprotectSheet(
            self.file_index,
            sheet.encode(ENCODE),
            passwd.encode(ENCODE),
            len(password) > 0,
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def unprotect_workbook(self, *password: str) -> None:
        """
        Remove protection for workbook, specified the optional password
        parameter to remove workbook protection with password verification.

        Args:
            *password (str): Optional password for workbook protection
            verification

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        lib.UnprotectWorkbook.restype = c_char_p
        passwd = password[0] if len(password) > 0 else ""
        err = lib.UnprotectWorkbook(
            self.file_index, passwd.encode(ENCODE), len(password) > 0
        ).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)

    def update_linked_value(self) -> None:
        """
        Fix linked values within a spreadsheet are not updating in Office Excel
        application. This function will be remove value tag when met a cell have
        a linked value.

        Notice:
            After opening generated workbook, Excel will update the linked value
            and generate a new value and will prompt to save the file or not.

        Returns:
            None: Return None if no error occurred, otherwise raise a
            RuntimeError with the message.
        """
        lib.UpdateLinkedValue.restype = c_char_p
        err = lib.UpdateLinkedValue(self.file_index).decode(ENCODE)
        if err != "":
            raise RuntimeError(err)


def cell_name_to_coordinates(cell: str) -> Tuple[int, int]:
    """
    Converts alphanumeric cell name to [X, Y] coordinates or returns an error.

    Args:
        cell (str): The cell reference

    Returns:
        Tuple[int, int]: Return a tuple containing the column number, row number
        if no error occurred, otherwise raise a RuntimeError with the message.
    """
    lib.CellNameToCoordinates.restype = types_go._CellNameToCoordinatesResult
    res = lib.CellNameToCoordinates(cell.encode(ENCODE))
    err = res.err.decode(ENCODE)
    if not err:
        return res.col, res.row
    raise RuntimeError(err)


def column_name_to_number(name: str) -> int:
    """
    Convert Excel sheet column name (case-insensitive) to int. The function
    returns an error if column name incorrect.

    Args:
        name (str): The column name

    Returns:
        int: Return the column number as a integer if no error occurred,
        otherwise raise a RuntimeError with the message.
    """
    lib.ColumnNameToNumber.restype = types_go._IntErrorResult
    res = lib.ColumnNameToNumber(name.encode(ENCODE))
    err = res.err.decode(ENCODE)
    if not err:
        return res.val
    raise RuntimeError(err)


def column_number_to_name(num: int) -> str:
    """
    Convert the integer to Excel sheet column title.

    Args:
        num (int): The column number

    Returns:
        str: Return the column name as a string if no error occurred, otherwise
        raise a RuntimeError with the message.
    """
    lib.ColumnNumberToName.restype = types_go._StringErrorResult
    res = lib.ColumnNumberToName(c_int(num))
    err = res.err.decode(ENCODE)
    if not err:
        return res.val.decode(ENCODE)
    raise RuntimeError(err)


def coordinates_to_cell_name(col: int, row: int, *is_absolute: bool) -> str:
    """
    Converts [X, Y] coordinates to alpha-numeric cell name or returns an error.

    Args:
        col (int): The column number.
        row (int): The row number.
        *abs (bool): Optional boolean indicating whether to use absolute
        references. If provided and True, the cell name will use absolute
        references (e.g., $A$1).

    Returns:
        str: Return the cell name as a string if no error occurred, otherwise
        raise a RuntimeError with the message.
    """
    lib.CoordinatesToCellName.restype = types_go._StringErrorResult
    options = False
    if len(is_absolute) > 0:
        options = is_absolute[0]
    res = lib.CoordinatesToCellName(col, row, options)
    err = res.err.decode(ENCODE)
    if not err:
        return res.val.decode(ENCODE)
    raise RuntimeError(err)


def new_file() -> File:
    """
    Create new file by default template.

    Returns:
        File: A populated spreadsheet file struct.
    """
    return File(lib.NewFile())


def open_file(filename: str, *opts: Options) -> File:
    """
    This function take the name of a spreadsheet file and returns a populated
    spreadsheet file struct for it.

    Args:
        filename (str): The path to the Excel file to open.
        *opts (Options): Optional parameters for opening the file.

    Returns:
        File: Return a File object if if no error occurred, otherwise raise a
        RuntimeError with the message.
    """
    lib.OpenFile.restype, options = types_go._IntErrorResult, None
    if len(opts) > 0:
        options = byref(py_value_to_c(opts[0], types_go._Options()))
    res = lib.OpenFile(filename.encode(ENCODE), options)
    err = res.err.decode(ENCODE)
    if not err:
        return File(res.val)
    raise RuntimeError(err)


def open_reader(buffer: bytes, *opts: Options) -> Optional[File]:
    """
    Read data stream from bytes and return a populated spreadsheet file.

    Args:
        buffer (bytes): The contents buffer of the file
        *opts (Options): Optional parameters for opening the file.

    Returns:
        Tuple[Optional[File], Optional[Exception]]: A tuple containing a File
        object if successful, or None and an Exception if an error occurred.
    """
    lib.OpenReader.restype, options = types_go._IntErrorResult, None
    if len(opts) > 0:
        options = byref(py_value_to_c(opts[0], types_go._Options()))
    res = lib.OpenReader(cast(buffer, POINTER(c_ubyte)), len(buffer), options)
    err = res.err.decode(ENCODE)
    if err == "":
        return File(res.val)
    raise RuntimeError(err)
